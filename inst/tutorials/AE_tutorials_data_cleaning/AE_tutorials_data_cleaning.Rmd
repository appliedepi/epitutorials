---
title: "Applied Epi Tutorials - Data cleaning"
tutorial:
  id: "AE_tutorial_data_cleaning"
output: 
  learnr::tutorial:
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
description: >
  Learn how to get started with R, and how to import a dataset
---

<!-- NOTES: To edit images, edit them in the "images" folder that lives NEXT TO THE RMD FILE -->


<!-- Add JavaScript code for making the exercise code larger -->
<script language="JavaScript" src="js/exercise-font-size.js"></script>

```{r setup, include=FALSE}
library(learnr)          # create lessons from rmd
library(gradethis)       # evaluate exercises
library(sortable)        # questions on choosing order of commands
library(skimr)           # dataset summary
library(dplyr)           # wrangle data
library(tidyr)           # data handling
library(janitor)         # tables and clean_names()
library(forcats)         # factors
library(epikit)          # age categories
library(flair)           # highlight code
library(ggplot2)         # visualise data
library(gtsummary)       # visualise data
library(fontawesome)     # for emojis
library(DT)              # present tables

# library(RMariaDB)      # connect to sql database

## set options for exercises and checking ---------------------------------------

## Define how exercises are evaluated 
gradethis::gradethis_setup(
  ## note: the below arguments are passed to learnr::tutorial_options
  ## set the maximum execution time limit in seconds
  exercise.timelimit = 60, 
  ## set how exercises should be checked (defaults to NULL - individually defined)
  # exercise.checker = gradethis::grade_learnr
  ## set whether to pre-evaluate exercises (so users see answers)
  exercise.eval = FALSE 
)

# ## event recorder ---------------------------------------------------------------
# ## see for details:
# ## https://pkgs.rstudio.com/learnr/articles/publishing.html#events
# ## https://github.com/dtkaplan/submitr/blob/master/R/make_a_recorder.R
# 
# ## connect to your sql database
# sqldtbase <- dbConnect(RMariaDB::MariaDB(),
#                        user = 'sander', 
#                        password = 'E9hqb2Tr5GumHHu',
#                        # user     = Sys.getenv("userid"),
#                        # password = Sys.getenv("pwd"),
#                        dbname   = 'excersize_log',
#                        host     = "144.126.246.140")
# 
# 
# ## define a function to collect data
# ## note that tutorial_id is defined in YAML
#     ## you could set the tutorial_version too (by specifying version:) but use package version instead
# recorder_function <- function(tutorial_id, tutorial_version, user_id, event, data) {
# 
#   ## define a sql query
#   ## first bracket defines variable names
#   ## values bracket defines what goes in each variable
#   event_log <- paste("INSERT INTO responses (
#                        tutorial_id,
#                        tutorial_version,
#                        date_time,
#                        user_id,
#                        event,
#                        section,
#                        label,
#                        question,
#                        answer,
#                        code,
#                        correct)
#                        VALUES('", tutorial_id,  "',
#                        '", tutorial_version, "',
#                        '", format(Sys.time(), "%Y-%M%-%D %H:%M:%S %Z"), "',
#                        '", Sys.getenv("SHINYPROXY_PROXY_ID"), "',
#                        '", event, "',
#                        '", data$section, "',
#                        '", data$label,  "',
#                        '", paste0('"', data$question, '"'),  "',
#                        '", paste0('"', data$answer,   '"'),  "',
#                        '", paste0('"', data$code,     '"'),  "',
#                        '", data$correct, "')",
#                        sep = '')
# 
#     # Execute the query on the sqldtbase that we connected to above
#     rsInsert <- dbSendQuery(sqldtbase, event_log)
# 
# }
# 
# options(tutorial.event_recorder = recorder_function)

# data prep (must be in setup chunk) --------------------------------------------------------------------
linelist <- rio::import(system.file("dat/surveillance_linelist_20141201.csv", package = "epitutorials"))

# hide non-exercise code chunks ------------------------------------------------
knitr::opts_chunk$set(echo = FALSE)

```




## Introduction to R for Applied Epidemiology and Public Health

```{r, eval = TRUE, echo = FALSE, out.width = "100%"}
knitr::include_graphics("images/applied_epi_banner.png", error = F)
```

</br>

#### Welcome to Applied Epi's free self-paced tutorial series

This is the **second** tutorial in the series.  

* **This tutorial teaches**: Cleaning of public health data using core R functions in the {tidyverse}  
* **Target audience**: Public health practitioners, epidemiologists, clinicians, and researchers who cannot access our live courses  
* **Format**: R coding is performed *within* this tutorial window  
* **Offline access**: Follow [these instructions](www.training.appliedepi.org) to download and view offline in your RStudio  

</br>

All of our courses welcome beginners who have never coded before, and use examples and solutions for common public health challenges. Here are the differences between these tutorials and our live courses:  

:::: {style="display: flex;"}

::: {}
**These tutorials:**

 
* Help you get started with R  
* R on your computer is **not** required  
* Help is available at our public [Applied Epi Community](http://community.appliedepi.org) forum  

:::





::: {.col data-latex="{0.15\textwidth}"}
\ 
<!-- an empty Div (with a white space), serving as
a column separator -->
:::





::: {}
**Live courses:**  

* A comprehensive curriculum  
* Use R on your computer (we help with set up)  
* Immediate support and tips from live instructors with decades of frontline experience  


:::

::::

See our [educational philosophy](https://applied-epi-training.netlify.app/educational-approach.html), [live course offerings](www.training.appliedepi.org), and [email us](mailto:contact@appliedepi.org) for tutorial coaching options.  

</br>

#### About Applied Epi^TM^

**[Applied Epi](www.appliedepi.org) is a nonprofit organization that supports frontline public health practitioners through open-source tools, training, and support.** We are a team of 150 epidemiologists and public health practitioners with decades of ground-level experience in local public health and outbreak response.  

Our free [Epidemiologist R Handbook](www.epiRhandbook.com) has helped over **175,000 people** learn R and remains a vital resource for many practitioners. We have built a comprehensive ecosystem of tools, training, and support:  


:::: {style="display: flex;"}

::: {}
```{r, out.width = "65%", fig.align = "center", echo=F}
knitr::include_graphics("images/teaching_icon.png")
```

* **[Live R training courses](www.training.appliedepi.org)**
* **[Self-paced R tutorials](https://training.appliedepi.org)**
* **[Case studies](www.training.appliedepi.org)**
:::





::: {.col data-latex="{0.05\textwidth}"}
\ 
<!-- an empty Div (with a white space), serving as
a column separator -->
:::





::: {}
```{r, out.width = "65%", fig.align = "center", echo=F}
knitr::include_graphics("images/tools_icon.png")
```

* **[Epi R Handbook](www.epiRhandbook.com)**
* **[R packages](https://appliedepi.org/tools/)**
* **[Situation report templates](https://appliedepi.org/tools/)**
:::




::: {.col data-latex="{0.05\textwidth}"}
\ 
<!-- an empty Div (with a white space), serving as
a column separator -->
:::

::: {}
```{r, out.width = "65%", fig.align = "center", echo=F}
knitr::include_graphics("images/QA_icon.png")
```

* **[Q&A discussion forum](www.community.appliedepi.org)**
* **[R Help Desk](https://appliedepi.org/helpdesk/)**
* **Mentorship program**  
:::



::::



<form target="_blank" action="https://www.paypal.com/donate" method="post" target="_top">
<input type="hidden" name="hosted_button_id" value="YTEZELC8VBXV6" />
<input type="image" src="https://github.com/appliedepi/epiRhandbook_eng/raw/master/images/donate_button_long.png" border="0" name="submit" title="PayPal - The safer, easier way to pay online!" alt="Donate with PayPal button" />
<img alt="" border="0" src="https://www.paypal.com/en_US/i/scr/pixel.gif" />
</form>



</br>

#### Acknowledgements and partners  

Authors of this tutorial include:  

* Arran Hamlet  
* Neale Batra  

Funding for this tutorial was provided by Medicins sans frontieres (MSF) / Doctors without Borders and TEPHINET.  

**Click "Next Topic" to move to the next section of the tutorial, or navigate using the Table of Contents on the left.**  






## About this tutorial


### Learning objectives

In this tutorial you will learn and practice:  

* Using the pipe operator (`%>%`) to pass a dataset from one cleaning function to another
* The core {tidyverse} R functions used to reduce, clean, and modify data frames  

This tutorial adapts the [Data cleaning and core functions](https://epirhandbook.com/en/cleaning-data-and-core-functions.html) chapter of our free [ Epidemiologist R Handbook](https://epirhandbook.com/en/). 



#### Accompanying resources

This tutorial draws from chapters of our free [Epidemiologist R handbook](https://epirhandbook.com/en/) such as [R basics](https://epirhandbook.com/en/r-basics.html), [Importing and exporting](https://epirhandbook.com/en/import-and-export.html), and [R projects](https://epirhandbook.com/en/r-projects.html).  


#### Next steps  

After completing this tutorial, we recommend you complete our tutorial on "Cleaning data".  




### Review a dataset  

Because this tutorial is self-contained within this window, we will often ask you to look at the first few rows of practice datasets in the format below.  

Below, the dataset `linelist` is displayed. It contains `r nrow(linelist)` rows, but we are only showing the **first 25 rows** now.  

* Scroll to the right to see all the columns  
* Use the numbers buttons in the lower-right to page through the additional available rows (25 rows in this case)  
* Click a column name to sort the rows  
* Filter rows by clicking/typing in the empty box above the column  

```{r, echo=FALSE, eval=TRUE, message = FALSE, warning = FALSE}
DT::datatable(head(linelist, 25), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```



### Getting help  

To get help while completing this tutorial:  

1) Look for expandable green helper text  
2) Look for "hints" and "solutions" above the coding boxes   
3) Post a question in [Applied Epi Community](www.community.appliedepi.org) in the category for questions about Applied Epi Training  

The the coming tutorial sections we will demonstrate how to use these resources.  

### Helper text  

Here is what the "helper text" will look like. Click on it to expand the text.

<!--
NOTE: Below is the hint (all within details tags collapsed)
-->
<details>

<summary style='text-decoration: underline; color: darkgreen;'>`r fontawesome::fa("lightbulb", fill = "gold")` Click to read more</summary>
</br>

Here there will be some helpful tips or advice!


</br>
</details>




### Code boxes  

This tutorial does not assume that you have R or RStudio working on your computer. Therefore, you can complete coding exercises in these codeboxes within the tutorial. For example:  

**Type the following R command in the codebox and press "Submit answer"**. This command will cross-tabulate observations from the dataset `linelist` (displayed above), placing gender in the output table's rows and case definition in the output table's columns.  

```
tbl_cross(data = linelist, row = gender, col = case_def)
```

* Press "Hints" to see hints or tips  
* Press "Run code" to run the code to preview the result  
* Press "Start over" to revert the box to its original state  
* Press "Submit answer" to submit your code and compare it against the solution  


<!-- ```{r ex-demo-setup, echo=FALSE, eval=FALSE} -->
<!-- linelist <<- rio::import(system.file("dat/surveillance_linelist_20141201.csv", package = "epitutorials")) -->
<!-- ``` -->


```{r example-codebox, exercise = TRUE}
Type the code here
```

```{r example-codebox-hint, eval = FALSE, exercise = FALSE}
Type the code exactly as written, into the codebox. Then press Run
```

```{r example-codebox-hint2, eval = FALSE, exercise = FALSE}
tbl_cross(data = linelist, row = gender, col = case_def)
```

```{r example-codebox-solution, exercise = FALSE}
tbl_cross(data = linelist, row = gender, col = case_def)
```

```{r example-codebox-check, exercise = FALSE}
grade_this_code("Correct, you should see a cross-tabulation of the linelist, in which gender is in the rows and case definition is in the columns.")
```

`r fontawesome::fa("exclamation", fill = "red")` If you get the error: `It looks like this might not be valid R code...` try typing the code instead of copy/pasting into the codebox.  



### Quiz questions  

Please complete the quiz questions that you encounter throughout the tutorial. **Answering will help you** to comprehend the material, and will also help us to improve the exercises for future students.  

To practice, please answer the following questions:  

```{r quiz-use-helper, echo=F}
quiz(
  question_radio("When should I view the red 'helper' code?",
    answer("After trying to write the code myself", correct = TRUE),
    answer("Before I try coding", correct = FALSE),
    correct = "Reviewing best-practice code after trying to write yourself can help you improve",
    incorrect = "Please attempt the exercise yourself, or use the hint, before viewing the answer."
  )
)
```


```{r quiz-anxious, echo = FALSE}
question_numeric(
 "How anxious are you about beginning this tutorial - on a scale from 1 (least anxious) to 10 (most anxious)?",
 answer(10, message = "Try not to worry, we will help you succeed!", correct = T),
 answer(9, message = "Try not to worry, we will help you succeed!", correct = T),
 answer(8, message = "Try not to worry, we will help you succeed!", correct = T),
 answer(7, message = "Try not to worry, we will help you succeed!", correct = T),
 answer(6, message = "Ok, we will get there together", correct = T),
 answer(5, message = "Ok, we will get there together", correct = T),
 answer(4, message = "I like your confidence!", correct = T),
 answer(3, message = "I like your confidence!", correct = T),
 answer(2, message = "I like your confidence!", correct = T),
 answer(1, message = "I like your confidence!", correct = T),
 allow_retry = TRUE,
 correct = "Thanks for sharing. ",
 min = 1,
 max = 10,
 step = 1
)
```


### Icons  

You will see these icons throughout the exercises:

Icon  |Meaning
------|--------------------
`r fontawesome::fa("eye", fill = "darkblue")`|Observe  
`r fontawesome::fa("exclamation", fill = "red")`|Alert!  
`r fontawesome::fa("pen", fill = "brown")`|An informative note  
`r fontawesome::fa("terminal", fill = "black")`|Time for you to code!  
`r fontawesome::fa("window-restore", fill = "darkgrey")`|Change to another window  
`r fontawesome::fa("bookmark", fill = "orange")`|Remember this for later  



### Getting help on Applied Epi Community  

Our other site [Applied Epi Community](www.community.appliedepi.org) is a public Q&A and discussion forum. You can post a question in the category "Applied Epi Training" about the content in these tutorials. A member of the community may help you by voluntarily answering your question.  

* Be sure to clearly reference which tutorial and which question you are stuck on  
* Explain what you have already tried to do  
* Thank anyone who replies for their time  















## Install and Load R packages {#packages}

To use basic functions with public health data, the tidyverse metapackage is very useful. Tidyverse loads the dplyr, ggplot2, and other packages that are useful in epi data analysis. 

We've preloaded the below packages for now. Installation and loading of these packages is described on the EpiRHandbook [_Suggested Packages_](https://epirhandbook.com/en/suggested-packages-1.html) page. 


In this assignment we'll work with X R packages, let's load them!

```{r load-package, exercise = TRUE}
pacman::p_load(___)
```

```{r load-package-hint}
pacman::p_load(rio, here, janitor, tidyverse)

```

```{r load-package-check}
grade_this_code("You are correct, the packages you need for this lesson are now loaded!")
```

```{r eval=FALSE}
pacman::p_load(learnr, here, rio, janitor, tidyverse)
```

### Recommended R packages for public health

See this Epi R Handbook LINK for our recommended packages.


## Import data {#import} 
https://www.epirhandbook.com/en/import-and-export.html
Import that data and save it as "raw" file

To import data from a sub-folder, the `import()` command should be modified so that it correctly tells R where to search for this file. This is done using the here() function. 

```{r import-demo-subfolder, echo=T, eval=F}
linelist <- import(here("data", "linelist.xlsx"))   # import data and save as named object
```


## Begin pipe chain

What is a pipe chain?  

A pipe chain refers to the use of the "pipe" operator `%>%` to chain together operations (such as cleaning, reordering and manipulating) for altering a dataset. 

This allows us to carry out several different modifications of the data frame in a single operation. It can be helpful to think of the pipe operator `%>%` as telling the computer "and then" between your operational commands.  

The order of this pipeline is important as operations occur sequentially, and so improperly ordered arguments may fail or (potentially more dangerously!) give incorrect values or unwanted outcomes.

Below, we describe a series of R commands that clean a dataset in preparation for analysis. Can you put them in the correct sequence?  

```{r sortable_question, echo = FALSE}
function_order <- c( "Begin with the raw dataset", "Clean the synatax of the column names", "Recode values in column 'temperature' column to ensure they are in celsius", "Create column 'fever' as binary Yes/No based on numeric column 'temperature'", "Create a new column 'case_definition' by referencing the columns 'fever', 'epilink' and 'lab_result'", "Filter to remove rows with suspect cases")

# Initialize the question
question_rank(
  "Arrange these functions in order to clean, select all columns with date in the name, and then print these names:",
  answer(function_order, correct = TRUE),
  answer(rev(function_order), correct = FALSE, message = "Other direction!"),
  allow_retry = TRUE
)
```

This was a very simple example to practice thinking about combining a sequence of commands into a cleaning command. As we progress through the chapter you will gain familiarity with the R functions to do each of these steps, and how to incorporate them into increasingly complex examples.

## Column names

In R, column names are the header, or top, value of a column and are used as the default value in figures.  

In other statistical software (such as SAS and STATA) "labels"  co-exist as longer printed versions of shorter column names. While this functionality does exist in R, it is not emphasized. For displaying reader-friendly column names in plots and tables, we typically adjust the labels directly in the code used to create the plot or table.  

As you will type column names often, they should should be "clean" and simple in the following ways:  

*   Short
*   No spaces (replace with underscores)
*   No unusual characters (&, #, <, >, ...)
*   Similar style nomenclature (e.g. all date columns named like **date_**onset, **date_**report, **date_**death, ...)

`r emo::ji("cross mark")` `weight (in kilograms)`  
`r emo::ji("cross mark")` `exposure#1`
`r emo::ji("cross mark")` `age>5`  
`r emo::ji("cross mark")` `onset date` and `day of infection` and `reported`  

`r emo::ji("check")` `wt_kg`  
`r emo::ji("check")` `exp1` 
`r emo::ji("check")` `age_over5`  
`r emo::ji("check")` `date_onset` and `date_inf` and `date_report`  


These are often not what real, raw, data and linelists look like, luckily R has a set of very handy and easy to use tools to clean and standardize column names.

For example, if we look at the example linelist using the `names()` function:
```{r, echo = T, eval = T}
names(linelist)
```
We can see that there are numerous violations of this clean syntax. We have names with spaces (infection date), different naming patterns for dates (date onset vs infection date) and there must have been a merged header across the last two columns (as the second last column i called "merged_header" and the last "...28" indicating it was assigned a placeholder name (it is the 28th column)). 

```{r rhetorical1, echo = FALSE}
question_text(
  "Can you think of a reason why it is useful to have a clean syntax for data organization and analysis?",
  answer_fn(function(value) {
    if (grepl(paste(letters, collapse = "|"), value)) {
      correct("")
    }
  }, )
)
```

### Automatic cleaning

Manually changing these column names to the preferred clean syntax would be time consuming, error prone and would need to be repeated everytime new versions of the linelist became available. Luckily, R has some helpful functions to make this process much faster and reproducible.

The first function we will explore in detail is the `clean_names()` function from the **janitor** package. This function does a lot of the hard work of cleaning column names for us. It does this through:

* Converting names to consist of only underscores, numbers and letters
* Accented characters are transliterated to ASCII (e.g. german o with umlaut becomes “o”, spanish “enye” becomes “n”)
* Capitalization preference for the new column names can be specified using the case = argument
* You can specify specific name replacements by providing a vector to the replace = argument (e.g. replace = c(onset = "date_of_onset"))

Here we can see the differences in the column names of the cleaned and uncleaned dataset.

```{r, echo = T, eval = T}
linelist %>%                              #Define the dataset, and then
  names()                                     #Display the column names

linelist %>%                              #Define the dataset, and then
         clean_names() %>%                    #clean the dataset columns, and then
         names()                              #Display the column names

```

You can see that this has done a lot of the work for us, replacing spaces with "_", and ensuring there are no unusual characters. However, if we want to standardize the entire dataset to the "clean syntax" described previously, we will have to include additional cleaning stages.

For example, if we wanted to use a similar style nomenclature such as **date_**, then we would have to carry out additional, manual, steps to the columns `infection_date`, `hosp_date`, `date_of_outcome`.

### Manual name cleaning

This manual name cleaning can be done through the function `rename()` from the **dplyr** package as part of a pipe chain. Here the function follows the syntax `NEW = OLD`. So to clean the linelist, rename the columns previously mentioned and then display the names, we would do the following:

```{r, echo = T, eval = T}
linelist %>%
  clean_names() %>%
         #New name         #Old names
  rename(date_onset = onset_date,
         date_report = date_of_report,
         district_res = adm3_name_res,
         district_det = adm3_name_det) %>%
  names()

```



```{r quiz0}
quiz(
  question("What arguments would you specify to change the column name 'aches' to 'malaise'?",
    answer("rename(aches = malaise)"),
    answer("clean_names()"),
    answer("names(aches = malaise)"),
    answer("rename(malaise = aches)", correct = TRUE)
  )
)
```



Using what we have learned, can you `clean()`, `rename()`, `select()` and `head()` to recreate the output below?

```{r, eval = T}
  linelist %>%                                        #Define the dataset, and then
         clean_names() %>%                              #clean the dataset columns, and then
                #New name   Old name
         rename(date_onset = onset_date,
                date_report = date_of_report) %>%     #rename the select columns, and then
         select(case_id, date_infection, date_outcome) %>%
         head()
```

```{r clean_rename_select, exercise = TRUE}

```

```{r clean_rename_select-hint}
Remember the order of your pipe chain is important.
```

```{r clean_rename_select-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal(message =  "Excellent, you have cleaned the dataset and subset to the columns you want")
    # Default to failing grade with feedback
    fail()
  })
```

```{r clean_rename_select-solution}
linelist %>%
         clean_names() %>%
         rename(date_infection = infection_date,
                date_outcome = date_of_outcome) %>%
         select(case_id, date_infection, date_outcome) %>%
         head()
```

This gives you an insight into how to clean and subset a dataset, however when you have a large dataset manually specifiying columns can be cumbersome. Sometimes you want to extract columns with a specific prefix/suffix, or when they contain a certain word. 

Rather than manually typing these out, and especially if we have a cleaned dataset adhering to the "clean style" syntax specified previously, we can use "tidyselect" helper functions

### Tidyselect helper functions

Tidyselect helper functions are functions that work within **dplyr** functions such as `select()`, `across()` or `summarize()`. These offer convenient shortcuts for selecting subsets of columns that match specified criteria:

* `everything()` - all othecolumns not mentioned
* `last_col()` - the last column
* `where()` - applies a function to all columns and selects those which are true
  * example: `select(where(is.numeric))`
  * This would select all columns where the class is numeric
* `contains()` - columns containing a character string
  * example: `select(contains("time"))`
* `starts_with()` - matches to a specified prefix
  * example: `select(starts_with("date_"))`
* `ends_with()` - matches to a specified suffix
  * example: `select(ends_with("_post"))`
* `matches()` - to apply a regulaexpression (regex)
  * example: `select(matches("[pt]al))`
  * Regular expression (regex) refers to a sequence of characters that specifies a search pattern in text. If you are unfamiliawith regex, then there some aspects may seem non-intuitive, foa good introduction to the use of regex please see https://cran.r-project.org/web/packages/stringr/vignettes/regular-expressions.html.
* `num_range()` - a numerical range
  * example: `select(num_range("week", 1:5))`
* `any_of()` - matches if the column exists, but returns no erroif it is not found
  * example: `select(any_of(date_onset, date_death, cardiac_arrest))`
  
In addition to these we can use normal operators such as:

* `c()` - to list several columns
  * example: `select(c(date_onset, hosp_date, gender))`
* `:` - to select consecutive columns
  * example: `select(1:5)`
* `!` - fothe opposite
  * example: `select(!c(date_onset, hosp_date, gender))`
  * This would _not_ select date_onset, hosp_date, gender
* `&` - AND
  * example: `select(matches("date" & "outcome"))`
* `|` - OR
  * example: `select(matches("date" | "outcome"))`

Select can also be used to remove columns, rather than keep, by putting the minus symbol "-" in front of the column name

```{r, eval = T, echo = T}
linelist %>%
  select(-c(date_onset, fever:vomit)) %>% #This will remove date_onset and all columns from fever to vomit
  names()
```

You can also remove a column using **base R** syntax, by defining it as NULL. For example:
```{r, eval = F, echo = T}
linelist$date_onset <- NULL #Deletes column with **base R** syntax
```

```{r quiz1}
quiz(
  question("Which of these column names follows a clean syntax?",
    answer("date hospitalisation"),
    answer("date_of_patient_hospitalisation"),
    answer("date@hospitalisation"),
    answer("date_hosp", correct = TRUE)
  ),
  question("Which of these functions can be used to rename columns?",
           answer("rename()", correct = TRUE),
           answer("clean_names()", correct = TRUE),
           answer("head()"),
           answer("select()", correct = TRUE)
           ),
  question("Why is it useful to follow a similar style nomenclature (all date columns starting *date_*) for column names?",
    answer("It looks good when you output tables and figures"),
    answer("It helps us find relevant columns and makes omissions/errors less likely", correct = TRUE),
    answer("R is very inflexible and only allows certain combinations of words"),
    answer("It allows us to sort the dataset by alphabetical order")
  ),
  question("In which order would you place these functions in order to output only the names of the columns 'date_onset' and 'outcome' from linelist",
           answer("clean_names(), select(date_onset, outcome), names()", correct = TRUE),
           answer("select(date_onset, outcome), clean_names(), names()"),
           answer("clean_names(), select(-c(date_onset, outcome)), names()"),
           answer("clean_names(), select(date_onset, outcome), head()")
           )
   
)
```

Can you write a pipe chain that drops the columns from `lon` to `source` from linelist?

```{r drop_lon_to_source, exercise = TRUE}

```

```{r drop_lon_to_source-hint}
It is good practice to clean your column names, but it is not necessary to in this example. 

Remember, you do not need to specifiy each column name individually that you want to drop between two columns
```

```{r drop_lon_to_source-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal(message = "You have correctly linked the functions in order and displayed the names of the cleaned dataset, good work!")
    # Default to failing grade with feedback
    fail()
  })
```

```{r drop_lon_to_source-solution}
linelist %>%
         select(-c(lon:source))
```

We need to put all columns with a "date" in them into the same nomenclature (*date_*) and then subset linelist to contain these and all symptom columns.
How would you do this using only `clean_names()` and `select()`?

```{r date_symptom_subset, exercise = TRUE}

```

```{r date_symptom_subset-hint}
You will have to combine renaming, a tidyselect helper function and a normal operator within select() to efficiently clean and subset
```

```{r date_symptom_subset-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal(message = "You have correctly linked the functions in order and displayed the names of the cleaned dataset, good work!")
    # Default to failing grade with feedback
    fail()
  })
```

```{r date_symptom_subset-solution}
linelist %>%
  clean_names() %>%
  select(date_infection = infection_date,
         date_hospitalisation = hosp_date,
         starts_with("date_"),
         fever:vomit)
```

## Column creation and transformation

Creating new columns and transforming existing ones is easily done in R, where we recommend using the **dplyr** package function `mutate()` which uses the syntax `NEW = TRANSFORMATION`.

For example, this would create a new column called `new_col` where each row has the value of 10.

```{r eval = F, echo = T}
linelist %>%
  mutate(new_col = 10)
```

You can also reference pre-existing columns to perform calculations. For example, to calculate the Body Mass Index (BMI) we can use the formula BMI = kg/m^2 using the column `ht_cm` and `wt_kg` through:
```{r eval = T, echo = T}
linelist %>%
  mutate(bmi = wt_kg/(ht_cm/100)^2) %>%
  select(wt_kg, ht_cm, bmi) %>%          #This selects just the wt_kg, ht_cm and bmi columns
  head()                                 #This displays the top 6 rows to check
```

In **base** R this would be carried out with
```{r, echo = T, eval = F}
linelist$bmi = linelist$wt_kg / (linelist$ht_cm / 100) ^ 2)
```

We can also create multiple new columns at once, which are separated with a comma and should begin on a new line
```{r eval = T, echo = T}
linelist %>%                       
  mutate(
    new_var_dup    = case_id,             # new column = duplicate/copy another existing column
    new_var_static = 7,                   # you can create static variables that are the same for each row
    new_var_static = new_var_static + 5,  # you can overwrite a column, and it can be a calculation using other variables
    ) %>% 
  select(case_id, hospital, date_hospitalisation, contains("new")) %>%
  head()
```

```{r rhetorical2, echo = FALSE}
question_text(
  "Can you think of a reason why we would create a new column in R, rather than the csv we take the data from?",
  answer_fn(function(value) {
    if (grepl(paste(letters, collapse = "|"), value)) {
      correct("")
    }
  }, )
)
```


```{r quiz2}
quiz(
  question("Which function can be used to create new columns?",
    answer("select()"),
    answer("mutate()", correct = TRUE),
    answer("rename()"),
    answer("clean_names()")
  ))
```

Can you take what you have learned in the previous chapters and create a new column called `age_months` from `age`, and then subset to only include `age`, `age_months` and `gender`? Note, you should ensure that all values in age are the same unit (specified in `age_unit`), and convert according to this.

```{r date_mutate, exercise = TRUE}

```

```{r date_mutate-hint}
You can use ifelse() to carry out different operations based on another value, this is a vectorised version of the if statement, and so will run through each row of a column and return an answer
ifelse(age_unit == "years",   #The condition, if the value in the column age_unit DOES equal years then the function will return...
       age * 12,              #this value, and if the value in column age_unit DOES NOT equal years, then the function will return...
       age                    #the value in age without manipulation
)
```

```{r date_mutate-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal(message = "Great, you have created a new column based and learned about the ifelse() function.")
    # Default to failing grade with feedback
    fail()
  })
```

```{r date_mutate-solution}
linelist %>%
  mutate(age_months = ifelse(age_unit == "years", age * 12, age)) %>%
  select(age, age_months, gender)
```


### Converting column class

Columns contain values that are dates, numbers or logical values (TRUE/FALSE) and will only behave if correctly classified. Trying to sum "2" and "1" of class character will return an error, and summing 2 and 1 of class numeric will return 3.

The class of a column is displayed when we use `skim()` and individually we can check the value of columns with `class()`. For instance, below we can see that this column has been incorrectly assigned as "character". 

```{r, echo = T, eval = T}
class(linelist$age)
```

Can you reassign the class of this column to numeric using `as.numeric()`?

```{r change_class, exercise = TRUE}
linelist %>%
  
```

```{r change_class-hint}
In order to change a value to numeric, you can use the function as.numeric()
```

```{r change_class-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal(message = "Great, you have created a new column based and learned about the ifelse() function.")
    # Default to failing grade with feedback
    fail()
  })
```

```{r change_class-solution}
linelist %>%
    mutate(age = as.numeric(age))
```

Using the same syntax you can convert columns to character with `as.character()` or to logical operators, `as.logical()` or to a factor with `as.factor()` with **base** R, or `as_factor()` from the package **forcats**.

Converting dates is slightly trickier, and it requires careful attention to the format (e.g. "Month/Day/Year" or "Day/Month/Year"). After converting to the class Date, check your data to confirm each value was converted correctly.

### Grouping data

Often your data will be grouped, and so functions such as `mutate()` will behave differently than if the data is not grouped. Additionally, summarising functions such as `mean()`, `min()`, `max()` will calculate by group and not by all the rows.

```{r rhetorical3, echo = FALSE}
question_text(
  "Why might we want to group data?",
  answer_fn(function(value) {
    if (grepl(paste(letters, collapse = "|"), value)) {
      correct("")
    }
  }, )
)
```

```{r, eval = T, echo = T}
# age normalized to mean of ALL rows
linelist %>% 
    summarize(mean_age = mean(age, na.rm = T))

# age normalized to mean of hospital group
linelist %>% 
    group_by(hospital) %>% 
    summarize(mean_age = mean(age, na.rm = T))
```

Can you group outcome by `age_cat` *and* `gender`, then use `count(outcome)` in order to produce a summary table of outcome by age category and gender?

```{r age_sex_group, exercise = TRUE}
linelist %>%
  
```

```{r age_sex_group-hint}
You can include multiple arguments in group_by(), and remember to end your pipe chain with count(outcome).
```

```{r age_sex_group-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal(message = "Great, you have created a new column based and learned about the ifelse() function.")
    # Default to failing grade with feedback
    fail()
  })
```

```{r age_sex_group-solution}
linelist %>% 
  group_by(age_cat, gender) %>% 
  count(outcome)
```


### Transform multiple columns

The function across() allows us to apply a function to everything specified within it. Columns are specified using the `.cols =` function, either individually, or with "tidyselect" helper functions. The function to apply to these columns is then specified with `.fns = ` (note the function is specified _without_ parentheses "()").

```{r, eval = T, echo = T}
linelist %>%
  mutate(across(.cols = c(temp, ht_cm, wt_kg), .fns = as.character))
```

```{r quiz3}
quiz(
  question("What will this pipe chain do?",
    answer("Check the columns temp, ht_cm and wt_kg to see if they are the character class and return a TRUE/FALSE"),
    answer("Check the columns temp, ht_cm and wt_kg to see if they are the character class"),
    answer("Convert the columns temp, ht_cm and wt_kg to character class and make new columns"),
    answer("Convert the columns temp, ht_cm and wt_kg to character class and update existing columns", correct = TRUE)
  ))
```

Can you update the above function using "tidyselect" helper functions to convert any columns that contain "date" to character?

```{r tidyselect_date_character, exercise = TRUE}
linelist %>%
```

```{r tidyselect_date_character-hint}
Remember you can use tidyhelper functions such as "select()"
```

```{r tidyselect_date_character-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal(message = "Great, you have created a new column based and learned about the ifelse() function.")
    # Default to failing grade with feedback
    fail()
  })
```

```{r tidyselect_date_character-solution}
linelist %>%
  mutate(across(.cols = contains("date"), .fns = as.character))
```

### coalesce()

This **dplyr** function allows us to "fill in" missing values with the first available value in an order you specify. For example, you have two vectors, one containing the patient’s village of detection and another containing the patient’s village of residence. You can use coalesce to pick the first non-missing value for each index:

```{r, eval = T, echo = T}
village_detection <- c("a", "b", NA,  NA)
village_residence <- c("a", "c", "a", "d")

village <- coalesce(village_detection, village_residence)
village    # print
```

This works the same way for a dataset

```{r, eval = T, echo = T}
linelist %>% 
  transmute(first_date = coalesce(date_infection, date_onset),#transmute() is the same as mutate(), except it drops everything not specified in the brackets
            date_infection, 
            date_onset) %>% 
  head()
```

```{r rhetorical5, echo = FALSE}
question_text(
  "Can you think of any analysis or programmatic issues that might arise when two distinct columns, and how we might mitigate them?",
  answer_fn(function(value) {
    if (grepl(paste(letters, collapse = "|"), value)) {
      correct("")
    }
  }, )
)
```

### Cumulative math

In your datasets, you may want to take cumulative sum/mean/min/max etc values across all the rows in the data frame. For example, calculating the cumulative sum of cases across an outbreak or per day can give us an idea of how the infection is progressing. To calculate the cumulative sum across the entire outbreak, we would do the following:

```{r}

linelist %>%                                 #Begin with the case linelist, and then
  count(date_onset) %>%                      #count of rows per day, as column 'n' by default, and then
  mutate(cumulative_cases = cumsum(n)) %>%   #new column, of the cumulative sum at each row, and then
  head(10)                                   #display the first 10 rows

```

Can you use what you have learned in order to produce a cumulative sum (in a column called cumulative_cases) of the epidemic by healthcare setting from linelist?

```{r cumulative_sum, exercise = TRUE}
linelist %>% 

```

```{r cumulative_sum-hint}
Remember to use group_by() 

```

```{r cumulative_sum-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal(message = "Great, it's hard to see because we have 1629 rows, but you have correctly grouped and cumulatively summed by hospital!")
    # Default to failing grade with feedback
    fail()
  })
```

```{r cumulative_sum-solution}
linelist %>% 
  group_by(hospital) %>%
    count(date_onset) %>%
    mutate(cumulative_cases = cumsum(n))
```

### Deduplication

The package **dplyr** has the function  `distinct()` which removes duplicated rows in the dataset, by default it considers all columns though this can be adjusted. Here we will ensure that no rows are 100% duplicates of other rows (evaluated across all columns) in the dataset `linelist`. We are comparing the number of rows in the original and de-duplicated 

```{r, echo = T, eval = T}
nrow(linelist)

linelist %>%
  distinct() %>%
  nrow()
```
As you can see the linelist goes from 6611 rows to 6609 These omitted rows would have been 100% duplicates of other rows.

### Quiz

Now we are going to run through everything we have learned so far in order to convert `linelist` into `linelist`, this will require several steps.

* Cleaning names, both automatically and manually renaming date columns to the clean syntax
* Removing the columns "row_num", "merged_header" and "x28"
* De-duplicating
* Adding in the new column "bmi"
* Converting all date columns to the date class, generation and age to numeric class

```{r linelist_to_linelist, exercise = TRUE}


```

```{r linelist_to_linelist-hint}
You have already done each of these steps individually (and some together), this is a case of remembering how to use rename(), select(), mutate() and a few other functions.

```

```{r linelist_to_linelist-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal(message = "You have strung together numerous functions in order to create a clean dataset, you are well on your way to becoming a data cleaning expert.")
    # Default to failing grade with feedback
    fail()
  })
```

```{r linelist_to_linelist-solution}
linelist %>%
  janitor::clean_names() %>% 
  rename(date_infection       = infection_date,
         date_hospitalisation = hosp_date,
         date_outcome         = date_of_outcome) %>% 
  select(-c(row_num, merged_header, x28)) %>% 
  distinct() %>% 
  mutate(bmi = wt_kg / (ht_cm/100)^2) %>% 
  mutate(across(contains("date"), as.Date), 
         generation = as.numeric(generation),
         age = as.numeric(age))
```


## Re-code values

You will occasionally have to re-code values, this can be due to a number of reasons

* To edit one specific value (e.g. one date in the wrong format)
* To reconcile values not spelled the same
* To create a new column of categorical values
* To create a new column of numeric categories (e.g. age categories)

### Specific values

To change values manually we can use the `recode()` function within `mutate()`. For instance, to fix a date that has been incorrectly included we use the following:
```{r, echo = F, eval = F}
linelist %>%                             #Old value     #New value
  mutate(date_onset = recode(date_onset, "2014-14-15" = "2014-04-15"))
```

Another example of when you would use recode is if you have a column with several different spellings and missing values.

```{r, echo = T, eval = T}
table(linelist$hospital, useNA = "always")  # print table of all unique values, including missing  
```

As you can see, we need to do some manual cleaning in order to correct misspellings. 

```{r, echo = T, eval = T}
linelist_updated <- linelist %>% 
  mutate(hospital = recode(hospital,
                     # for reference: OLD = NEW
                      "Mitylira Hopital"  = "Military Hospital",
                      "Mitylira Hospital" = "Military Hospital",
                      "Military Hopital"  = "Military Hospital",
                      "Port Hopital"      = "Port Hospital",
                      "Central Hopital"   = "Central Hospital",
                      "other"             = "Other",
                      "St. Marks Maternity Hopital (SMMH)" = "St. Mark's Maternity Hospital (SMMH)"
                      ))

table(linelist_updated$hospital, useNA = "always")

```


```{r rhetorical6, echo = FALSE}
question_text(
  "Why would you recode in R rather than manually in the dataset?",
  answer_fn(function(value) {
    if (grepl(paste(letters, collapse = "|"), value)) {
      correct("")
    }
  }, )
)
```

Can you quickly recode the values in the column `gender` from "f" to "Female" and "m" to "Male"? Once this is done, can you also `select()` the column `gender` only and show the first 6 rows with `head()`?

```{r gender_recode, exercise = TRUE}
linelist %>%

```

```{r gender_recode-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal()
    # Default to failing grade with feedback
    fail()
  })
```

```{r gender_recode-solution}
linelist %>%
  mutate(gender  = recode(gender, "f" = "Female",
                          "m" = "Male")) %>%
  select(gender) %>%
  head()
  
```

### Simple logic

We can also re-code based on logical criteria, you can use `replace()` within `mutate()` and use it with logical conditions in order to specify which rows to change using the following general syntax

```{r, eval = F, echo = T}
mutate(col_to_change = replace(col_to_change, criteria for rows, new value))
```

For instance, if you know a row that is identified with a certain id has the wrong value (such as gender), you can correct this using a logical condition. 
```{r, eval = F, echo = T}
linelist %>% 
  mutate(gender = replace(gender, case_id == "2195", "Female"))
```

This will find the row with the `case_id` of "2195" and change the gender to "Female".

Another useful tool for simple logic is `ifelse()`, `if_else()` and `case_when()`. These "if else" commands are simplified versions of an `if` and `else` programming statement with the general syntax of
```{r, eval = F, echo = T}
ifelse(condition, value to return if condition evaluates to TRUE, value to return if condition evaluates to FALSE)
```

Here we are creating a column `source_known` column where the value of a row is "known" if the row's value in column `source` is _not_ missing. If it _is_ missing then it will be set to "unknown"

```{r, eval = F, echo = T}
linelist %>% 
  mutate(source_known = ifelse(!is.na(source), "known", "unknown"))
```

if_else() is a function from **dplyr** that handles dates. Note that if the "true" value is a date, the "false" value must also qualify a date, hence the use of `NA_real_` instead of `NA`.
```{r, eval = F, echo = T}
linelist %>% 
  mutate(date_death = if_else(outcome == "Death", date_outcome, NA_real_))
```

```{r quiz4}
quiz(
  question("Which of these simple logical statements would replace 'Other' with 'Unidentified' in the column 'hospital'?",
    answer("mutate(hospital = ifelse(hospital == 'Other', 'Unidentified', hospital))", correct = TRUE),
    answer("mutate(hospital = ifelse(hospital == 'Unidentified', 'Other', hospital))"),
    answer("mutate(hospital = ifelse(hospital == 'Other', 'Unidentified', 'Identified'))"),
    answer("mutate(hospital = ifelse(Other == 'hospital', 'Unidentified', hospital))")
  ))
```

### Complex logic

Complex logic takes simple logic to the next level and allows us to input several different criteria. For example, if you are re-coding into several new groups you can use **dplyr**'s `case_when()` function. 

`case_when()` command consists of logical statements and outcomes seperated by a "tilde" `~`. The logic criteria are on the left and the values on the right with statements seperated by commas.

For example, here we utilize the columns `age` and `age_unit` to create a column `age_years`:

```{r, echo = T, eval = F}
linelist <- linelist %>% 
  mutate(age_years = case_when(
            age_unit == "years"  ~ age,       # if age is given in years
            age_unit == "months" ~ age/12,    # if age is given in months
            is.na(age_unit)      ~ age,       # if age unit is missing, assume years
            TRUE                 ~ NA_real_)) # any other circumstance, assign missing
```

The criteria are applied in the order the `case_when()` statement is written. So if the criteria is met by the first argument (here, `age_unit` == "years"), then the remaining criteria are not tested. It is therefore important to order your arguments correctly, as in when writing a pipe chain `%>%`, from most specific to generic.

Along those lines, in your final statement, place TRUE on the left-side, which will capture any row that did not meet any of the previous criteria. The right-side of this statement could be assigned a value like “check me!” or missing.

**DANGER: Values on the right-side must all be the same class - either numeric, character, date, logical, etc. To assign missing (NA), you may need to use special variations of NA such as NA_character_, NA_real_ (for numeric or POSIX), and as.Date(NA). Read more in Working with [dates](https://www.epirhandbook.com/en/working-with-dates.html).**

Here we want to look at the temperatures of people recorded in the dataset. However, upon first visualization we can see that there is some discordence in the dataset.

```{r, echo = F, eval = T, error = FALSE}
ggplot(data = linelist) +
    geom_histogram(aes(x = temp), binwidth = 1) +
  scale_x_continuous(limits = c(30, 110), breaks = seq(30, 110, by = 10)) +
      labs(x = "Temperature", y = "Count")
```

Most of the values are located between 35 and 41, as expected if we were recording temperatures in °C, however some values are around 100, and so we can deduce that these have been incorrectly recorded in °F. Using the formula, `°C = (°F − 32) * 5/9`, can you use complex logic to convert values that are above 90 and below 120 to Celcius?

```{r temp_convert_logic, exercise = TRUE}
linelist %>%
```

```{r temp_convert_logic-hint}
You will need to use case_when and greater than (temp >) and less than (temp <) combined with the and (&)
```

```{r temp_convert_logic-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal(message = "You've successfully used complex logic, great work.")
    # Default to failing grade with feedback
    fail()
  })
```

```{r temp_convert_logic-solution}
linelist %>%
    mutate(temp = case_when(temp > 90 & temp < 120 ~ (temp - 32) * 5/9,
                            TRUE ~ temp))
  
```

### Missing values

Missing values are an ever present facet of dealing with real world data, and it is important to correctly identify and handle them in order to highlight data gaps and adjust our analysis accordingly. There are several inbuilt functions for dealing with missing data, depending on the scenario and the class of data.

```{r rhetorical7, echo = FALSE}
question_text(
  "Why is it important to correctly account for missing data? Can you think about how this may impact our understanding of the data and any analyses that are performed?",
  answer_fn(function(value) {
    if (grepl(paste(letters, collapse = "|"), value)) {
      correct("")
    }
  }, )
)
```

To change missing values (`NA`) to a specific value, such as "Missing", we can use the **dplyr** function `replace_na()` with `mutate()`

```{r}
linelist <- linelist %>% 
  mutate(hospital = replace_na(hospital, "Missing"))
```

Factors are R’s way to handle ordered values such as c("First", "Second", "Third") or to set the order that values (e.g. hospitals) appear in tables and plots. If your data are of the class Factor and you try to convert NA to “Missing” by using `replace_na()`, you will get this error: invalid factor level, NA generated. You have tried to add “Missing” as a value, when it was not defined as a possible level of the factor, and it was rejected.

The easiest way to solve this is to use the **forcats** function `fct_explicit_na()` which converts a column to class factor, and converts NA values to the character “(Missing)”.

```{r}
linelist %>% 
  mutate(hospital = fct_explicit_na(hospital))
```

To convert a specific value to NA, use **dplyr**’s `na_if()`. The command below performs the opposite operation of `replace_na()`. In the example below, any values of “Missing” in the column hospital are converted to NA.

```{r}
linelist <- linelist %>% 
  mutate(hospital = na_if(hospital, "Missing"))
```

However, `na_if()` cannot be used for logical criteria (e.g. “all values > 99”) - use `replace()` or `case_when()` for this:

```{r}
# Convert temperatures above 40 to NA 
linelist <- linelist %>% 
  mutate(temp = replace(temp, temp > 40, NA))

# Convert onset dates earlier than 1 Jan 2000 to missing
linelist <- linelist %>% 
  mutate(date_onset = replace(date_onset, date_onset > as.Date("2000-01-01"), NA))
```

We are now going to practice these different methods of replacing NA values. In `linelist` can you do the following:

* Convert NA values in the `age` column to "Age not recorded"
* If values in `bmi` are below 10 or above 40, replace them with NA

```{r NA_practice, exercise = TRUE}

```

```{r NA_practice-hint}
You will need to use both na_if() and replace(), and a few logical operators ("|", "<", ">")
```

```{r NA_practice-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal()
    # Default to failing grade with feedback
    fail()
  })
```

```{r NA_practice-solution}
linelist %>%
 mutate(age = na_if(age, "Age not recorded"),
        bmi = replace(bmi, bmi < 10 | bmi > 40, NA))
```

## Numerical categories

There are numerous reasons why you may want to categorise numeric values, such as for age groups, lab values etc. R has several ways of doing this.

* `age_categories()`, from the **epikit** package
* `cut()` from **base R**
* `case_when()`
* quantile breaks with `quantile()` and `ntile()`

### age_categories()

With the **epikit** package, you can use the `age_categories()` function to easily categorize and label numeric columns (note: this function can be applied to non-age numeric variables too). As a bonus, the output column is automatically an ordered factor.

Here are the required inputs:

* A numeric vector (column)
* The `breakers = ` argument, provide a numeric vector of break points for new groups.

For example

```{r, echo = T, eval = T}
linelist <- linelist %>% 
  mutate(
    age_cat = age_categories(             # create new column
      age_years,                            # numeric column to make groups from
      breakers = c(0, 5, 10, 15, 20,        # break points
                   30, 40, 50, 60, 70)))

# Display the table
table(linelist$age_cat, useNA = "always")
```

Break values specified are by default the lower bounds, here the categorisation occurs so that the left/lower side is "open" and "inclusive". . You can adjust how the labels are displayed with `separator = `, with the default as "-". 

You may also want to set an upper limit, this will categorise any value above the last breaker as `NA`. This is doing using `ceiling = TRUE`.

```{r, echo = T, eval = T}
linelist <- linelist %>% 
  mutate(
    age_cat = age_categories(             # create new column
      age_years,                            # numeric column to make groups from
      breakers = c(0, 5, 10, 15, 20,        # break points
                   30, 40, 50, 60, 70),
      ceiling = TRUE))

# Display the table
table(linelist$age_cat, useNA = "always")
```

Alternatively, instead of using `breakers = ` you can provide `lower = `, `upper = ` and `by = `:

```{r, echo = T, eval = T}
linelist <- linelist %>% 
  mutate(
    age_cat = age_categories(             # create new column
      age_years,                            # numeric column to make groups from
      lower = 0,
      upper = 70,
      by = 5))

# Display the table
table(linelist$age_cat, useNA = "always")
```

```{r quiz5}
quiz(
  question("Which of these age_categories() specifications would create breaks at 0, 25, 50 and 75?",
    answer("age_categories(age_years, breakers = c(0, 25, 50, 75))", correct = TRUE),
    answer("age_categories(age_years, lower = 0, upper = 75, by = 5)", correct = TRUE),
    answer("age_categories(age_years, breakers = c(0, 25, 50, 75), ceiling = FALSE", correct = TRUE),
    answer("age_categories(age_years, breakers = 25, lower = 0, upper  = 75)")
  ))
```

### cut()

`cut()` is a **base** R alternative to `age_categories()`. The basic syntax is to first provide a numeric culumn to be cut (`age_years`), and then the `breaks = ` argument which is a numeric vector `c()` of break points. 

By default, the categorisation occurs so the right/upper side is "open" and "inclusive", *this is the opposite behavior to `age_categories()` function*. You can reverse this behavior, and so align it with the `age_categories()` function through adding the `right = TRUE` argument.

Thus, by default, “0” values are excluded from the lowest group, and categorized as NA! “0” values could be infants coded as age 0 so be careful! To change this, add the argument `include.lowest = TRUE` so that any “0” values will be included in the lowest group. The automatically-generated label for the lowest category will then be “[A],B]”. Note that if you include the `include.lowest = TRUE` argument *and* `right = TRUE`, the extreme inclusion will now apply to the highest break point value and category, not the lowest.

```{r, echo = T, eval = T}
# Create new variable, by cutting the numeric age variable
# lower break is excluded but upper break is included in each category
linelist <- linelist %>% 
  mutate(
    age_cat = cut(
      age_years,
      breaks = c(0, 5, 10, 15, 20,
                 30, 50, 70, 100),
      include.lowest = TRUE         # include 0 in lowest group
      ))

# tabulate the number of observations per group
table(linelist$age_cat, useNA = "always")
```

**It is very important to check your work here, do so by cross-tabulating the numeric and category columns**

You may want to assign NA values a label such as “Missing”. Because the new column is class Factor (restricted values), you cannot simply mutate it with `replace_na()`, as this value will be rejected. Instead, use `fct_explicit_na()` from the **forcats** package, as explained in the Factors page.

```{r, echo = T, eval = T}
linelist <- linelist %>% 
  
  # cut() creates age_cat, automatically of class Factor      
  mutate(age_cat = cut(
    age_years,
    breaks = c(0, 5, 10, 15, 20, 30, 50, 70, 100),          
    right = FALSE,
    include.lowest = TRUE,        
    labels = c("0-4", "5-9", "10-14", "15-19", "20-29", "30-49", "50-69", "70-100")),
         
    # make missing values explicit
    age_cat = fct_explicit_na(
      age_cat,
      na_level = "Missing age")  # you can specify the label
  )    

# table to view counts
table(linelist$age_cat, useNA = "always")
```

Can you write some code to create a new column `temp_cat` to convert values in `temp` to the following categories:

* Less than 38 - "No fever"
* Greater than or equal to 38 & less than 39.4 - "Low grade fever"
* Greater than or equal to 39.4 - "High grade fever"

set the lower bound to 0, and then display only the columns `temp` and `temp_cat`?

```{r cut_temp, exercise = TRUE}

```

```{r cut_temp-hint}
You will need to use the function cut() and specify the correct breaks, and remember that cut() occurs on the right side, and age_categories() the left, so if you are using cut() you may also need to include the argument right = FALSE 
```

```{r cut_temp-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal()
    # Default to failing grade with feedback
    fail()
  })
```

```{r cut_temp-solution}
  linelist %>% 
  mutate(temp_cat = cut(
    temp,
    breaks = c(0, 38, 39.4, 45),          
    right = FALSE,
    labels = c("No fever", "Low grade fever", "High grade fever"))) %>%
  select(temp, temp_cat)
```

### Quantile breaks

Quantiles, or percentiles, typically refer to a value below which a proportion of values fall. For example, the 95th percentile of ages in `linelist` would be the age below which 95% of the ages fall. 

However in common speech, “quartiles” and “deciles” can also refer to the groups of data as equally divided into 4, or 10 groups (note there will be one more break point than group).

To get quantile break points, you can use quantile() from the **stats** package from **base** R. You provide a numeric vector (e.g. a column in a dataset) and vector of numeric probability values ranging from 0 to 1.0. The break points are returned as a numeric vector. Explore the details of the statistical methodologies by entering ?quantile.

* If your input numeric vector has any missing values it is best to set na.rm = TRUE
* Set names = FALSE to get an un-named numeric vector

``` {r, echo = T, eval = T}
quantile(linelist$age_years,               # specify numeric vector to work on
  probs = c(0, .25, .50, .75, .90, .95),   # specify the percentiles you want
  na.rm = TRUE)                            # ignore missing values 
```

You can use the results of `quantile()` as break points in `age_categories()` or `cut()`. Below we create a new column deciles using `cut()` where the breaks are defined using `quantiles()` on age_years. Below, we display the results using `tabyl()` from janitor so you can see the percentages (see the Descriptive tables page). Note how they are not exactly 10% in each group.

```{r, echo = T, eval = T}
linelist %>%                                # begin with linelist
  mutate(deciles = cut(age_years,           # create new column decile as cut() on column age_years
    breaks = quantile(                      # define cut breaks using quantile()
      age_years,                               # operate on age_years
      probs = seq(0, 1, by = 0.1),             # 0.0 to 1.0 by 0.1
      na.rm = TRUE),                           # ignore missing values
    include.lowest = TRUE)) %>%             # for cut() include age 0
  janitor::tabyl(deciles)                   # pipe to table to display
```

Can you create a quantile break that gives us `linelist$age_years` broken down in 10% increments from 0 to 1? Remember to remove `NA` values. 

```{r quant_break, exercise = TRUE}

```

```{r quant_break-hint}
Remember you can specify the probs either manually, or by using seq()
```

```{r quant_break-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal()
    # Default to failing grade with feedback
    fail()
  })
```

```{r quant_break-solution}
quantile(linelist$age_years, probs = seq(0, 1, by = 0.1), na.rm = TRUE)
```

### Evenly sized groups

Another tool to make numeric groups is the **dplyr** function `ntile()` which breaks your data into evenly sized groups - *be aware that unlike in `quantile()` the same value could appear in more than one group.* Firstly you provided the numeric vector (the column) and the number of groups with the values in the new column created being the group "numbers" not the range of values themselves (as when you use `cut()`).

```{r, echo = T, eval = T}
# make groups with ntile()
ntile_data <- linelist %>% 
  mutate(even_groups = ntile(age_years, 10))

# make table of counts and proportions by group
ntile_table <- ntile_data %>% 
  janitor::tabyl(even_groups)
  
# attach min/max values to demonstrate ranges
ntile_ranges <- ntile_data %>% 
  group_by(even_groups) %>% 
  summarize(
    min = min(age_years, na.rm=T),
    max = max(age_years, na.rm=T)
  )

# combine and print - note that values are present in multiple groups
left_join(ntile_table, ntile_ranges, by = "even_groups")

```

```{r rhetorical8, echo = FALSE}
question_text(
  "Can you think of a situation, other than age, where we might want to split the data into evenly sized groups?",
  answer_fn(function(value) {
    if (grepl(paste(letters, collapse = "|"), value)) {
      correct("")
    }
  }, )
)
```

## Filter rows

A typical cleaning step after cleaning columns and recoding values is to filter the dataset to specific rows with the **dplyr** function `filter()`.

### Simple filter

The simplest way of filtering, is to use a logical condition ("==", "!=", ">", "<", etc), so that only rows where the logical statement is `TRUE` are kept. For example here, we are only keeping rows where the gender is equal to "f".

```{r, echo = T, eval = T}
nrow(linelist)

linelist %>% 
  filter(gender == "f") %>%
  nrow()
```

From the reduction in rows you can see that we have subset the dataset.

```{r quizage}
quiz(
  question("Which of these uses of simple logic would enable the filter to remove any ages greater than 90?",
    answer("filter(age_years != 90)"),
    answer("filter(age_years > 90)"),
    answer("filter(age_years < 90)", correct = TRUE),
    answer("filter(age_years == 90)")
  ))
```

### Filter out missing values

A common use of filtering is to remove rows that have missing values. This can either be done for any missing values in _any_ column, by not specifiying any arguments in the **tidyr** function `drop_na()`, or specific columns by including them within `drop_na()`.

```{r, echo = T, eval = T}
linelist %>% 
  drop_na(case_id, age_years)  # drop rows with missing values for case_id or age_years
```

Can you now write a pipe chain to filter out any rows with a `bmi` of more than 20, and then drop any rows that have NA values in any column between fever and vomit, and then show the first 6 rows with `head()`?

```{r filter_row_first, exercise = TRUE}

```

```{r filter_row_first-hint}
Remember to use logical operators, and that you can specify a group of consective columns with ":".
```

```{r filter_row_first-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal()
    # Default to failing grade with feedback
    fail()
  })
```

```{r filter_row_first-solution}
  linelist %>% 
  filter(bmi < 20) %>%
  drop_na(fever:vomit) %>%
  head()
```

### Filter by row number

You can also filter by row number, this is done using the **dplyr** function `row_number()`. Here you will often use the operator `%in%` to specify all numbers within a supplied vector. For example, this filter command would remove all rows between 2 and 20 `filter(row_number() %in% 2:20)`.

Can you write a filter that will remove all **odd** numbered rows from linelist, between 1 and 100 (i.e 1, 3, 5,...,99)?

```{r filter_row_number, exercise = TRUE}

```

```{r filter_row_number-hint}
You do not need to manually write the numbers, you can use seq() to create a vector of all the odd numbers between 1 and 100.
```

```{r filter_row_number-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal()
    # Default to failing grade with feedback
    fail()
  })
```

```{r filter_row_number-solution}
  linelist %>% 
  filter(row_number() %in% seq(1, 100, by = 2))
```

## Row-wise calculations

We may want to perform a calculation within a row, and to do so we can use `rowwise()` from **dplyr**. 

For example, this code applies `rowwise()` and then creates a new column that sums the number of the specified symptom columns that have value “yes”, for each row in the linelist. The columns are specified within sum() by name within a vector `c()`. `rowwise()` is essentially a special kind of `group_by()`, so it is best to use `ungroup()` when you are done.

```{r, echo = T, eval = T}
linelist %>%
  rowwise() %>%
  mutate(num_symptoms = sum(c(fever, chills, cough, aches, vomit) == "yes")) %>% 
  ungroup() %>% 
  select(fever, chills, cough, aches, vomit, num_symptoms) # for display

```

As you specify the column to evaluate, you may want to use the “tidyselect” helper functions.

Can you write a function that does the following?

* Applies `rowwise()` so the following operation (`sum()`) is applied within each row (not summing entire columns)
* Creates new column `num_NA_dates`, which contains the number of `NA` values in the columns `date_infection`, `date_onset`, `date_hospitalisation` and `date_outcome`
* `ungroup()` to remove the effects of `rowwise()` for subsequent steps
* To `select()` and display, using `head()`, all columns which have "date_" in their name

You could also provide other functions, such as max() to get the latest or most recent date for each row:

```{r rowwise_calc, exercise = TRUE}

```

```{r rowwise_calc-hint}
Remember, for evaluating whether a value is NA, we use "is.na" rather than "== NA". 
```

```{r rowwise_calc-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal()
    # Default to failing grade with feedback
    fail()
  })
```

```{r rowwise_calc-solution}
linelist %>%
    rowwise() %>%
    mutate(num_NA_dates = sum(is.na(c(date_infection, date_onset, date_hospitalisation, date_outcome)))) %>%
  select(contains("date")) %>%
  head()
```

## Arrange and sort

The **dplyr** function `arrange()` allows us to sort or order rows by column values. List the columns in the order they should be sorted on, and specify `.by_group = TRUE` if you want the sorting to occur by any groupings in the data.

By default the column will be sorted in "ascending" order, but you can change this to "descending" by wrapping it with `desc()`.

Sorting data with `arrange()` is particularly useful when making Tables for presentation, using `slice()` to take the “top” rows per group, or setting factor level order by order of appearance.

For example, to sort the our linelist rows by hospital, then by `date_onset` in descending order, we would use:

```{r, echo = T, eval = T}
linelist %>% 
  drop_na(date_onset) %>%                     #Remember to drop NA values
   arrange(hospital, desc(date_onset)) %>%    #the function "desc()" sorts in descending order
   select(case_id, hospital, date_onset)
```

Can you now arrange the column `source` in `linelist` by `date_infection` in ascending order *and* `date_onset` in descending order, then only display rows where `gender == "m"` and the columns `gender`, `date_infection` and `date_onset`? Remember to drop `NA` values from the columns you are sorting by.

```{r arrange_filter, exercise = TRUE}

```

```{r arrange_filter-hint}
Take this step by step, you have successfully completed all these steps individually, it is just a case of tying everything you have learned together!
```

```{r arrange_filter-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal()
    # Default to failing grade with feedback
    fail()
  })
```

```{r arrange_filter-solution}
linelist %>% 
  drop_na(date_infection, date_onset) %>%
   arrange(source, date_infection, desc(date_onset)) %>%
  filter(gender == "m") %>%
   select(gender, date_infection, date_onset)
```






















