---
title: "Applied Epi Tutorials - Data cleaning"
tutorial:
  id: "AE_tutorial_data_cleaning"
output: 
  learnr::tutorial:
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
description: >
  Learn how to get started with R, and how to import a dataset
---

<!-- NOTES: To edit images, edit them in the "images" folder that lives NEXT TO THE RMD FILE -->


<!-- Add JavaScript code for making the exercise code larger -->
<script language="JavaScript" src="js/exercise-font-size.js"></script>

```{r setup, include=FALSE}
library(learnr)          # create lessons from rmd
library(gradethis)       # evaluate exercises
library(sortable)        # questions on choosing order of commands
library(skimr)           # dataset summary
library(dplyr)           # wrangle data
library(tidyr)           # data handling
library(janitor)         # tables and clean_names()
library(forcats)         # factors
library(lubridate)       # dates
library(stringr)         # string handling
library(epikit)          # age categories
library(flair)           # highlight code
library(ggplot2)         # visualise data
library(gtsummary)       # visualise data
library(fontawesome)     # for emojis
library(DT)              # present tables

# library(RMariaDB)      # connect to sql database

## set options for exercises and checking ---------------------------------------

## Define how exercises are evaluated 
gradethis::gradethis_setup(
  ## note: the below arguments are passed to learnr::tutorial_options
  ## set the maximum execution time limit in seconds
  exercise.timelimit = 60, 
  ## set how exercises should be checked (defaults to NULL - individually defined)
  # exercise.checker = gradethis::grade_learnr
  ## set whether to pre-evaluate exercises (so users see answers)
  exercise.eval = FALSE 
)

# ## event recorder ---------------------------------------------------------------
# ## see for details:
# ## https://pkgs.rstudio.com/learnr/articles/publishing.html#events
# ## https://github.com/dtkaplan/submitr/blob/master/R/make_a_recorder.R
# 
# ## connect to your sql database
# sqldtbase <- dbConnect(RMariaDB::MariaDB(),
#                        user = 'sander', 
#                        password = 'E9hqb2Tr5GumHHu',
#                        # user     = Sys.getenv("userid"),
#                        # password = Sys.getenv("pwd"),
#                        dbname   = 'excersize_log',
#                        host     = "144.126.246.140")
# 
# 
# ## define a function to collect data
# ## note that tutorial_id is defined in YAML
#     ## you could set the tutorial_version too (by specifying version:) but use package version instead
# recorder_function <- function(tutorial_id, tutorial_version, user_id, event, data) {
# 
#   ## define a sql query
#   ## first bracket defines variable names
#   ## values bracket defines what goes in each variable
#   event_log <- paste("INSERT INTO responses (
#                        tutorial_id,
#                        tutorial_version,
#                        date_time,
#                        user_id,
#                        event,
#                        section,
#                        label,
#                        question,
#                        answer,
#                        code,
#                        correct)
#                        VALUES('", tutorial_id,  "',
#                        '", tutorial_version, "',
#                        '", format(Sys.time(), "%Y-%M%-%D %H:%M:%S %Z"), "',
#                        '", Sys.getenv("SHINYPROXY_PROXY_ID"), "',
#                        '", event, "',
#                        '", data$section, "',
#                        '", data$label,  "',
#                        '", paste0('"', data$question, '"'),  "',
#                        '", paste0('"', data$answer,   '"'),  "',
#                        '", paste0('"', data$code,     '"'),  "',
#                        '", data$correct, "')",
#                        sep = '')
# 
#     # Execute the query on the sqldtbase that we connected to above
#     rsInsert <- dbSendQuery(sqldtbase, event_log)
# 
# }
# 
# options(tutorial.event_recorder = recorder_function)

# data prep (must be in setup chunk) --------------------------------------------------------------------
linelist_raw <- rio::import(system.file("dat/surveillance_linelist_20141201.csv", package = "epitutorials")) %>% 
  select(-bmi, -case_def) %>% 
  mutate(age = as.numeric(age)) %>% 
  mutate(hospital = na_if(hospital, ""))

# create epilink column
linelist_raw <- linelist_raw %>% 
  mutate(epilink = sample(
    c(rep("yes", .85 * nrow(linelist_raw)),
      rep("no", .10 * nrow(linelist_raw)),
      rep(NA, .05 * nrow(linelist_raw))),
    size = nrow(linelist_raw), replace = TRUE)
    ) %>% 
  
# create lab confirmed
  mutate(lab_confirmed = sample(
    c(rep(TRUE, .75 * nrow(linelist_raw)),
      rep(FALSE, .15 * nrow(linelist_raw)),
      rep(NA, .10 * nrow(linelist_raw))),
    size = nrow(linelist_raw), replace = TRUE)
    )

# Randomly convert some temperatures to Fahrenheit instead of celcius for an exercise later
set.seed(1)
take_these <- sample(1:nrow(linelist_raw), 42)
linelist_raw$temp[take_these] <- (linelist_raw$temp[take_these] * 9/5) + 32


linelist <- rio::import(system.file("dat/surveillance_linelist_clean_20141201.rds", package = "epitutorials"))

# hide non-exercise code chunks ------------------------------------------------
knitr::opts_chunk$set(echo = FALSE)

```




## Introduction to R for Applied Epidemiology and Public Health

```{r, eval = TRUE, echo = FALSE, out.width = "100%"}
knitr::include_graphics("images/applied_epi_banner.png", error = F)
```

</br>

#### Welcome to Applied Epi's free self-paced tutorial series

This is the **second** tutorial in the series.  

* **This tutorial teaches**: Cleaning of public health data using core {tidyverse} R functions  
* **Target audience**: Public health practitioners, epidemiologists, clinicians, and researchers who cannot access our live courses  
* **Format**: R coding is performed *within* this tutorial window  
* **Offline access**: Follow [these instructions](www.training.appliedepi.org) to download and view offline in your RStudio  

</br>

All of our courses welcome beginners who have never coded before, and use examples and solutions for common public health challenges. Here are the differences between these tutorials and our live courses:  

:::: {style="display: flex;"}

::: {}
**These tutorials:**

 
* Help you get started with R  
* R on your computer is **not** required  
* Help is available at our public [Applied Epi Community](http://community.appliedepi.org) forum  

:::





::: {.col data-latex="{0.15\textwidth}"}
\ 
<!-- an empty Div (with a white space), serving as
a column separator -->
:::





::: {}
**Live courses:**  

* A comprehensive curriculum  
* Use R on your computer (we help with set up)  
* Immediate support and tips from live instructors with decades of frontline experience  


:::

::::

See our [educational philosophy](https://applied-epi-training.netlify.app/educational-approach.html), [live course offerings](www.training.appliedepi.org), and [email us](mailto:contact@appliedepi.org) for tutorial coaching options.  

</br>

#### About Applied Epi^TM^

**[Applied Epi](www.appliedepi.org) is a nonprofit organization that supports frontline public health practitioners through open-source tools, training, and support.** We are a team of 150 epidemiologists and public health practitioners with decades of ground-level experience in local public health and outbreak response.  

Our free [Epidemiologist R Handbook](www.epiRhandbook.com) has helped over **175,000 people** learn R and remains a vital resource for many practitioners. We have built a comprehensive ecosystem of tools, training, and support:  


:::: {style="display: flex;"}

::: {}
```{r, out.width = "65%", fig.align = "center", echo=F}
knitr::include_graphics("images/teaching_icon.png")
```

* **[Live R training courses](www.training.appliedepi.org)**
* **[Self-paced R tutorials](https://training.appliedepi.org)**
* **[Case studies](www.training.appliedepi.org)**
:::





::: {.col data-latex="{0.05\textwidth}"}
\ 
<!-- an empty Div (with a white space), serving as
a column separator -->
:::





::: {}
```{r, out.width = "65%", fig.align = "center", echo=F}
knitr::include_graphics("images/tools_icon.png")
```

* **[Epi R Handbook](www.epiRhandbook.com)**
* **[R packages](https://appliedepi.org/tools/)**
* **[Situation report templates](https://appliedepi.org/tools/)**
:::




::: {.col data-latex="{0.05\textwidth}"}
\ 
<!-- an empty Div (with a white space), serving as
a column separator -->
:::

::: {}
```{r, out.width = "65%", fig.align = "center", echo=F}
knitr::include_graphics("images/QA_icon.png")
```

* **[Q&A discussion forum](www.community.appliedepi.org)**
* **[R Help Desk](https://appliedepi.org/helpdesk/)**
* **Mentorship program**  
:::



::::



<form target="_blank" action="https://www.paypal.com/donate" method="post" target="_top">
<input type="hidden" name="hosted_button_id" value="YTEZELC8VBXV6" />
<input type="image" src="https://github.com/appliedepi/epiRhandbook_eng/raw/master/images/donate_button_long.png" border="0" name="submit" title="PayPal - The safer, easier way to pay online!" alt="Donate with PayPal button" />
<img alt="" border="0" src="https://www.paypal.com/en_US/i/scr/pixel.gif" />
</form>



</br>

#### Acknowledgements and partners  

Authors of this tutorial include:  

* Arran Hamlet  
* Neale Batra  

Funding for this tutorial was provided by Medicins sans frontieres (MSF) / Doctors without Borders and TEPHINET.  

**Click "Next Topic" to move to the next section of the tutorial, or navigate using the Table of Contents on the left.**  






## About this tutorial


### Learning objectives

In this tutorial you will learn and practice:  

* Using the pipe operator (`%>%`) to pass a dataset from one cleaning function to another
* The core {tidyverse} R functions used to reduce, clean, and modify data frames  

This tutorial adapts the [Data cleaning and core functions](https://epirhandbook.com/en/cleaning-data-and-core-functions.html) chapter of our free [ Epidemiologist R Handbook](https://epirhandbook.com/en/). 



#### Accompanying resources

This tutorial draws from chapters of our free [Epidemiologist R handbook](https://epirhandbook.com/en/) such as [R basics](https://epirhandbook.com/en/r-basics.html), [Importing and exporting](https://epirhandbook.com/en/import-and-export.html), and [R projects](https://epirhandbook.com/en/r-projects.html).  


#### Next steps  

After completing this tutorial, we recommend you complete our tutorial on "Cleaning data".  




### Review a dataset  

Because this tutorial is self-contained within this window, we will often ask you to look at the first few rows of practice datasets in the format below.  

Below, the dataset `linelist` is displayed. It contains `r nrow(linelist)` rows, but we are only showing the **first 25 rows** now. A "linelist" is a term used in applied epidemiology to refer to a table that contains key information about each case or suspect case in an outbreak. Each row represents one case, and the columns contain variables such as age, sex, date of symptom onset, outcomes, etc.  

* Scroll to the right to see all the columns  
* Use the numbers buttons in the lower-right to page through the additional available rows (25 rows in this case)  
* Click a column name to sort the rows  
* Filter rows by clicking/typing in the empty box above the column  

```{r, echo=FALSE, eval=TRUE, message = FALSE, warning = FALSE}
DT::datatable(head(linelist_raw, 25), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```



### Getting help  

To get help while completing this tutorial:  

1) Look for expandable green helper text  
2) Look for "hints" and "solutions" above the coding boxes   
3) Post a question in [Applied Epi Community](www.community.appliedepi.org) in the category for questions about Applied Epi Training  

The the coming tutorial sections we will demonstrate how to use these resources.  

### Helper text  

Here is what the "helper text" will look like. Click on it to expand the text.

<!--
NOTE: Below is the hint (all within details tags collapsed)
-->
<details>

<summary style='text-decoration: underline; color: darkgreen;'>`r fontawesome::fa("lightbulb", fill = "gold")` Click to read more</summary>
</br>

Here there will be some helpful tips or advice!


</br>
</details>




### Code boxes  

This tutorial does not assume that you have R or RStudio working on your computer. Therefore, you can complete coding exercises in these codeboxes within the tutorial. For example:  

**Type the following R command in the codebox and press "Submit answer"**. This command will cross-tabulate observations from the dataset `linelist` (displayed above), placing gender in the output table's rows and case definition in the output table's columns.  

```
tbl_cross(data = linelist, row = gender, col = case_def)
```

* Press "Hints" to see hints or tips  
* Press "Run code" to run the code to preview the result  
* Press "Start over" to revert the box to its original state  
* Press "Submit answer" to submit your code and compare it against the solution  


<!-- ```{r ex-demo-setup, echo=FALSE, eval=FALSE} -->
<!-- linelist <<- rio::import(system.file("dat/surveillance_linelist_20141201.csv", package = "epitutorials")) -->
<!-- ``` -->


```{r example-codebox, exercise = TRUE}
Type the code here
```

```{r example-codebox-hint, eval = FALSE, exercise = FALSE}
Type the code exactly as written, into the codebox. Then press Run
```

```{r example-codebox-hint2, eval = FALSE, exercise = FALSE}
tbl_cross(data = linelist, row = gender, col = case_def)
```

```{r example-codebox-solution, exercise = FALSE}
tbl_cross(data = linelist, row = gender, col = case_def)
```

```{r example-codebox-check, exercise = FALSE}
grade_this_code("Correct, you should see a cross-tabulation of the linelist, in which gender is in the rows and case definition is in the columns.")
```

`r fontawesome::fa("exclamation", fill = "red")` If you get the error: `It looks like this might not be valid R code...` try typing the code instead of copy/pasting into the codebox.  



### Quiz questions  

Please complete the quiz questions that you encounter throughout the tutorial. **Answering will help you** to comprehend the material, and will also help us to improve the exercises for future students.  

To practice, please answer the following questions:  

```{r quiz-use-helper, echo=F}
quiz(
  question_radio("When should I view the red 'helper' code?",
    answer("After trying to write the code myself", correct = TRUE),
    answer("Before I try coding", correct = FALSE),
    correct = "Reviewing best-practice code after trying to write yourself can help you improve",
    incorrect = "Please attempt the exercise yourself, or use the hint, before viewing the answer."
  )
)
```


```{r quiz-anxious, echo = FALSE}
question_numeric(
 "How anxious are you about beginning this tutorial - on a scale from 1 (least anxious) to 10 (most anxious)?",
 answer(10, message = "Try not to worry, we will help you succeed!", correct = T),
 answer(9, message = "Try not to worry, we will help you succeed!", correct = T),
 answer(8, message = "Try not to worry, we will help you succeed!", correct = T),
 answer(7, message = "Try not to worry, we will help you succeed!", correct = T),
 answer(6, message = "Ok, we will get there together", correct = T),
 answer(5, message = "Ok, we will get there together", correct = T),
 answer(4, message = "I like your confidence!", correct = T),
 answer(3, message = "I like your confidence!", correct = T),
 answer(2, message = "I like your confidence!", correct = T),
 answer(1, message = "I like your confidence!", correct = T),
 allow_retry = TRUE,
 correct = "Thanks for sharing. ",
 min = 1,
 max = 10,
 step = 1
)
```


### Icons  

You will see these icons throughout the exercises:

Icon  |Meaning
------|--------------------
`r fontawesome::fa("eye", fill = "darkblue")`|Observe  
`r fontawesome::fa("exclamation", fill = "red")`|Alert!  
`r fontawesome::fa("pen", fill = "brown")`|An informative note  
`r fontawesome::fa("terminal", fill = "black")`|Time for you to code!  
`r fontawesome::fa("window-restore", fill = "darkgrey")`|Change to another window  
`r fontawesome::fa("bookmark", fill = "orange")`|Remember this for later  



### Getting help on Applied Epi Community  

Our other site [Applied Epi Community](www.community.appliedepi.org) is a public Q&A and discussion forum. You can post a question in the category "Applied Epi Training" about the content in these tutorials. A member of the community may help you by voluntarily answering your question.  

* Be sure to clearly reference which tutorial and which question you are stuck on  
* Explain what you have already tried to do  
* Thank anyone who replies for their time  













## Setup  


### Install and Load R packages {#packages}

The first coding step of any cleaning process is to install and/or load all the R packages that will be used.  

We've pre-loaded the packages for this tutorial, but if writing an R script it is best to do this at the very top of the script, so that any reviewer can quickly see which packages are used.

If you are unfamiliar with this `pacman::p_load()` command, review the earlier tutorial on R basic syntax. In brief, this command will automatically install R packages if they are not already installed, *and* load them for use.  

Installation and loading of packages is described in the Epi R Handbook content on [Packages](https://epirhandbook.com/en/r-basics.html#packages) and [Suggested packages for public health](https://epirhandbook.com/en/suggested-packages-1.html).  

In this tutorial we use the following packages. Below they are written in a vertical style, with explanatory # comments to the right.  

```{r, echo=TRUE, eval=FALSE}
pacman::p_load(
  rio,            # for importing/exporting data
  here,           # for flexible file paths
  janitor,        # for cleaning and tabulating data
  epikit,         # useful functions for epidemiology
  tidyverse)      # contains many data cleaning functions
```

Note: the {tidyverse} meta-package is very useful because it includes the {dplyr}, {ggplot2}, and several other packages useful for data analysis and management.  







## Import data {#import}  

In this tutorial, we have pre-loaded the data. But if you were writing in an R script, your next command would be to import the "raw" or "unclean" data from where it is stored on your computer.  

As explained in the previous tutorial, we strongly recommend organizing your work within an [RStudio project](https://epirhandbook.com/en/r-projects.html). In this way, the "paths" to your data files will not break when used on different computers.  

Below is an command that imports the file "linelist.xlsx", which is located in the RStudio project's "data" folder.  

* The `here()` function, from the {here} package, creates the file path which automatically adjusts to whichever computer it is run on  
* The `import()` function, from the {rio} package, imports the data into R - no matter if it is .csv, .xlsx, .rds, etc.  
* The `<-` assignment operator stores the imported dataset in R as the object `linelist_raw` for later reference  

```{r import-demo-subfolder, echo=T, eval=F}
linelist_raw <- import(here("data", "linelist.xlsx"))
```

You can read more in the previous tutorial and in the [Epi R Handbook](https://www.epirhandbook.com/en/import-and-export.html) about how RStudio projects, the {here} package, and the {rio} package can be efficiently used together to make the data import process very easy!



### View the data  

Here is a scollable view of the raw dataset that we just imported:  

```{r, echo=FALSE, eval=TRUE, message = FALSE, warning = FALSE}
DT::datatable(head(linelist_raw, 25), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```


If you want, you can view this dataset in a pop-out window the `View()` command in the codebox below, with the name of the dataset in the parentheses. Try typing `View()` and writing `linelist_raw` in the parentheses (note the capital "V"), and click "Run code".  

```{r viewdata, exercise = TRUE}

```


```{r viewdata-solution, eval=FALSE}
View(linelist_raw)
```




## Exploratory analysis  

Before we begin cleaning, you must become familiar with the data. Here are some useful commands:  

* `nrow()` and `ncol()` can be used to print the number of columns or rows, respectively  
* `summary()` when used on a numeric column prints a concise summary of the values  
* `tabyl()` from the {janitor} package quickly prints a tabulation (counts) of the unique values in a character column  
* `skim()` from the {skimr} package prints a concise summary of the entire dataset  

Let's try a few examples:  


### Number of columns and rows  

Try running the command `nrow()`, placing the name of the dataset (`linelist_raw`) inside the parentheses.  

```{r nrow, exercise = TRUE}

```

```{r nrow-check}
grade_this_code("You got it correct! There are 685 rows in this raw dataset.")
```

```{r nrow-solution, eval=FALSE}
nrow(linelist_raw)
```



### Summary of a numeric column  

Another {base} function that is helpful, especially for numeric columns is `summary()`.  

For this function (and most other {base} functions), you again list the data frame (`linelist_raw`) and then use the `$` operator to tell the function which column to analyze. This operator "links" the name of the column to the name of the dataset. Remember - you can have multiple datasets in R at one time, so R must be told which one to use!  

For example, the analyze the column `bmi` (body mass index) you would run the command `summary(linelist_raw$bmi)`.  

Now you try - write the command to print a summary of the numeric column `age`:  

```{r summary, exercise = TRUE}

```

```{r summary-check}
grade_this_code("You got it correct! Review the information provided by the output.")
```

```{r summary-solution, eval=FALSE}
summary(linelist_raw$age)
```


```{r quiz-summary}
quiz(caption = "Quiz - Summary of a numeric column",
  question("What is the mean age?",
    allow_retry = T,
    answer("13", message = "No, this is the Median"),
    answer("16.15", correct = TRUE, message = "Yes this is correct!"),
    answer("70", message = "This is not correct, try again."),
    answer("10", message = "No, this is the Max value")
  ),
  question("How many age values are missing?",
    allow_retry = T,
    answer("0", message = "No, this is the minimum value"),
    answer("10", correct = TRUE, message = "Yes, NA is R's symbol for 'missing value'"),
    answer("5", message = "This is not correct, try again."),
    answer("23", message = "No, this is the 3 qtr value")
  )
)
```





### skim the data  

Now place the name of the linelist in the `skim()` function and run the code. What content appears?
  
```{r skim, exercise = TRUE}

```

```{r skim-check}
grade_this_code("You wrote it correctly. Now explore the output. See how it gives summary statistics for each column, depending on whether it is of class 'character' or 'numeric'.")
```

```{r skim-solution, eval=FALSE}
skim(linelist_raw)
```


**Review the output**. First `skim()` lists the number of each class of column (character, numeric, etc.). Then, it gives more detail for each of the columns. 

**What does the output show?**  

```{r quiz-skim}
quiz(caption = "Quiz - reviewing the data",
  question("How many columns are there in the data frame?)",
    allow_retry = T,
    answer("665", message = "No, this is the number of rows/observations"),
    answer("23", correct = TRUE, message = "Yes this is correct!"),
    answer("19", message = "This is not correct, try again."),
    answer("25", message = "No, this is the number of rows shown in the initial display")
  ),
   question("How many columns has R classified as numeric?",
    allow_retry = T,
    answer("32", message = "No, this is more than the columns in the dataset!"),
    answer("8", correct = TRUE, message = "Yes this is correct!"),
    answer("13", message = "No, this is the number of columns of class character"),
    answer("1", message = "No, this is the number of columns that are POSIXct - a type of date format")
  ),

  question("Review the information on character columns. What is the number of unique values in the hospital column?",
    allow_retry = T,
    answer("9", correct = TRUE),
    answer("Port Hospital"),
    answer("3"),
    answer("8")
  ),

  question("Review the information on numeric columns. What is the MEDIAN age?",
    allow_retry = T,
        answer("32.2"),
        answer("13", correct = TRUE, message = "Yes, the 50th percentile is equivalent to the median"),
        answer("1250"),
        answer("99.0")
  )
)
```



### Tabulate character values  

A quick function to create a table is the `tabyl()` function from the {janitor} package.  

Try running the command below. It is instructing R to create a simple table of counts using the `linelist_raw` data frame, on the contents of the column `gender`. 

```{r tabyl1, exercise = TRUE}
tabyl(linelist_raw, gender)
```

Now try editing the above command to run using the column `hospital`.  





### Column names

In R, column names are the header, or top, value of a column and are used as the default value in figures.  

In other statistical software (such as SAS and STATA) "labels"  co-exist as longer printed versions of shorter column names. While this functionality does exist in R, it is not emphasized. We typically adjust the labels directly in the code used to create the outputs such as plots or tables.  

As you will type column names often, they should should be "clean" and simple in the following ways:  

*   Short
*   No spaces (replace with underscores)
*   No unusual characters (&, #, <, >, ...)
*   Similar style nomenclature (e.g. all date columns named like **date_**onset, **date_**report, **date_**death, ...)

`r emo::ji("cross mark")` `weight (in kilograms)`  
`r emo::ji("cross mark")` `exposure#1`  
`r emo::ji("cross mark")` `age>5`  
`r emo::ji("cross mark")` `onset date` and `day of infection` and `reported`  

`r emo::ji("check")` `wt_kg`  
`r emo::ji("check")` `exp1`  
`r emo::ji("check")` `age_over5`  
`r emo::ji("check")` `date_onset` and `date_inf` and `date_report`  


We begin by looking at the column names of our `linelist_raw` dataset by using the `names()` function:  

```{r, echo = T, eval = T}
names(linelist_raw)
```

We can see that there are numerous violations of this clean syntax. We have names with spaces (`onset date`), different naming patterns for dates (`onset date` vs `date of report`), and names with special characters such as `wt (kg)`.  

```{r rhetorical1, echo = FALSE}
question_text(
  "Can you think of a reason why it is useful to have a clean syntax for data organization and analysis?",
  answer_fn(function(value) {
    if (grepl(paste(letters, collapse = "|"), value)) {
      correct("")
    }
  }, )
)
```













## Cleaning pipe chain  

Now that you have reviewed the data, you can begin to build a "pipe chain" in your R script that will clean the data.

A "pipe chain" refers to the use of the "pipe" operator `%>%` to link together several operations for altering a dataset (such as keeping certain rows or column, recoding values, de-duplicating, adding new columns, etc.).  

We "pass" or "pipe" the data frame from one function to the next. **It can be helpful to think of the pipe operator `%>%` as telling the computer "and then" between your functions.**  

The below graphic conveys the idea of a dataset becoming more and more clean/standard, step-by-step.  

```{r, eval = TRUE, echo = FALSE, out.width = "50%"}
knitr::include_graphics("images/cleaning.png")
```

In R syntax, a simplified "pipe chain" looks like below. The underscores would contain specifications for their command. The green # comments are simply for explanation.  

```{r, echo=T, eval=F}
# create a "clean" linelist with a cleaning pipe chain
######################################################
linelist <- linelist_raw %>%    # create "clean" dataset, starting with the raw
            clean_names() %>%   # clean the column names
            rename(___) %>%     # manually edit column names
            select(___) %>%     # select, remove, or re-order columns
            distinct(___) %>%   # de-duplicate rows
            mutate(___) %>%     # create or recode columns
            filter(___)         # keep only certain rows 
 
```


Remember - it may be tempting to exit R and go clean the dataset manually in the external CSV or Excel file... *but in almost all circumstances it is more reproducible and more efficient to record the changes in the code.*  

More than likely, you will receive another version of the "raw" data and all the cleaning work in the CSV file will be lost. However, if you have made the changes in an R script then you will have a record of all the adjustments, and it is easy to adjust your approach.  



### Keyboard shortcut  

R coders use the pipe operator `%>%` so frequently that there is a keyboard shortcut! You will want to memorize this:  

* Windows/Linux: Press Ctrl, Shift, and "m" at the same time  
* Mac: Press Cmd, Shift, and "m" at the same time  


### Order the commands  

The order of functions in the pipeline is important, because they are occur sequentially. Improperly ordered arguments may fail or (potentially more dangerously!) give incorrect or unwanted outcomes.  

Below, we describe a series of R commands that clean a dataset in preparation for analysis. Can you put them in the correct sequence?  

```{r sortable_question, echo = FALSE}
function_order <- c( "Begin with the raw dataset", "Clean the synatax of the column names", "Recode values in column 'temperature' column to ensure they are in celsius", "Create column 'fever' as binary Yes/No based on numeric column 'temperature'", "Create a new column 'case_definition' by referencing the columns 'fever', 'epilink' and 'lab_result'", "Filter to remove rows with suspect cases")

# Initialize the question
question_rank(
  "Arrange these functions in order to clean, select all columns with date in the name, and then print these names:",
  answer(function_order, correct = TRUE),
  answer(rev(function_order), correct = FALSE, message = "Other direction!"),
  allow_retry = TRUE
)
```

This was a very simple example to practice thinking about combining a sequence of commands into a cleaning command. As we progress through the chapter you will gain familiarity with the R functions to do each of these steps, and how to incorporate them into increasingly complex examples.







### Begin the cleaning pipe chain  

Below we will guide you though the first steps of building your pipe chain command:    

1) Begin by writing the name for your "clean" data frame, e.g. `linelist`  

```{r, echo=TRUE, eval=FALSE}
linelist
```

2) To the right, write the assignment operator `<-` to assign this object the value of the "raw" data frame (`linelist_raw`)  

```{r, echo=TRUE, eval=FALSE}
linelist <- linelist_raw
```

3) Now add a "pipe" to the right side, and the first cleaning function below

*The below command takes `linelist_raw`, cleans it's column names with `clean_names()`, and stores the result as `linelist`*  

```{r, echo=TRUE, eval=FALSE}
linelist <- linelist_raw %>% 
            clean_names()
```

4) Add additional cleaning steps by adding pipes and the next function on a new line  

```{r, echo=TRUE, eval=FALSE}
linelist <- linelist_raw %>% 
            clean_names() %>% 
            distinct() %>% 
            filter(age > 10)  
```

You can write explanatory # comments on the right side of each function (any text to the right of # is ignored by R):  

```{r, echo=TRUE, eval=FALSE}
linelist <- linelist_raw %>%    # create clean linelist
            clean_names() %>%   # standardize syntax of column names
            distinct() %>%      # de-duplicate rows
            filter(age > 10)    # keep only rows with age greater than 10  
```

The placement of new lines and spaces in R does not impact the code execution, but can impact how easy it is to read the code. The default indentations will look more like this:  

```{r, echo=TRUE, eval=FALSE}
linelist <- linelist_raw %>%   # create clean linelist
  clean_names() %>%            # standardize syntax of column names
  distinct() %>%               # de-duplicate rows
  filter(age > 10)             # keep only rows with age greater than 10  
```


Note that in this command format, we are using the assignment operator `<-` to *assign* and *define*/*re-define* the object `linelist`. Therefore, the modified dataset will not be printed. Printing will need to be done with a separate command. In this tutorial we will periodically print the `linelist` for you to see the changes.  


If using RStudio, you can view a data frame by clicking on it in the RStudio environment, or running the `View()` command, like `View(linelist)`.  








## Cleaning column names  

Typically the first cleaning step is to ensure your column names have standard, clean syntax. This makes it easier to reference them in later commands.  

Manually cleaning column names in the CSV or Excel file would be time consuming, error prone and would need to be repeated every time new versions of the linelist became available. Luckily, R has some helpful functions to make this process much faster and reproducible.


### Automatic name cleaning  

The first function in our pipe chain is the `clean_names()` function from the {janitor} package. This function does much of the hard work of cleaning column names for us!  

It does the following:  

* Converts names to consist of only underscores, numbers and letters  
* Removes special characters such as ( ), *, ^, #, and !  

In addition, note that:  

* Accented characters are transliterated to ASCII (e.g. german o with umlaut becomes “o”, spanish “enye” becomes “n”)
* Capitalization preference for the new column names can be specified using the `case = ` argument


Do you remember the column names in the "raw" data frame `linelist_raw`?  

```{r, echo=TRUE, eval=TRUE}
names(linelist_raw)
```

**In the codebox below, begin your pipe chain by piping the `linelist_raw` data frame to the `clean_names()` function, storing the result as `linelist`.**  


```{r start, exercise=TRUE}

```

```{r start-check}
grade_this_code("You got it correct! Now you have started your cleaning pipe chain.")
```

```{r start-hint}
Begin with this:  linelist <- linelist_raw 
```

```{r start-hint-2}
Then add a pipe, and on a new line write the clean_names() function
```

```{r start-hint-3}
linelist <- linelist_raw %>% 
  clean_names()
```

```{r start-solution, eval=FALSE}
linelist <- linelist_raw %>% 
  clean_names()
```

Do not expect any output, but you can now inspect the column names of the **cleaned** `linelist` using `names()` 

```{r cleannames, exercise=TRUE}

```

```{r cleannames-hint}
Put the name of the cleaned linelist within the parentheses
```

```{r cleannames-hint-2}
names(linelist)
```


```{r cleannames-solution, eval=FALSE}
names(linelist)
```

Of note: this `names()` command is not part of your pipe chain, you are simply running an independent check to see what your `clean_names()` function did.  

You can see that this has done a lot of the work for us, replacing spaces with "_", and ensuring there are no unusual characters (see the onset date, weight, and height columns).

`r fontawesome::fa("pen", fill = "brown")` Removing spaces from R is important because if a column name has spaces in it, you must refer to it within backticks \`  . Backticks are different from single quotation marks '. Doing this is rather annoying, so it is better to quickly replace all spaces with underscores via `clean_names()`.  








### Manual column name cleaning  

To finish cleaning our column names, we also want similar columns to have similar style nomenclature. For example, the date columns should all begin with **date_** so they sort and can be easily referenced together in later commands.  

Manual name cleaning can be done through the function `rename()` from the {dplyr} package as part of the pipe chain. Column "headers" in R are called "names" - that is an easy way to remember the `rename()` function.  

The `rename()` function allows you to specify a NEW column name, and the old column name with the syntax NEW = OLD. Multiple changes can be separated by commas, all within the parentheses.  

Below, `rename()` is added to the pipe chain after `clean_names()` (with a pipe operator `%>%`). Inside the parentheses, the column name `onset_date` is changed to `date_onset`, and the column `date_of_report` is changed to `date_report`.  

```{r, echo = T, eval = FALSE}
linelist %>%
  clean_names() %>%
  rename(date_onset = onset_date,
         date_report = date_of_report)
```

Note that the "old" names are the names *as cleaned by the `clean_names()` function*. Hence they have underscores instead of spaces.  


```{r quiz0}
quiz(
  question("What arguments would you specify to change the column name 'aches' to 'malaise'?",
    answer("rename(aches = malaise)", message = "Almost - the syntax is NEW = OLD"),
    answer("clean_names()", message = "No, clean_names() is better used for standardizing syntax"),
    answer("names(aches = malaise)", message = "No, the function names() just prints the names, it does not allow editing."),
    answer("rename(malaise = aches)", correct = TRUE),
    allow_retry = TRUE
  ),
    question("Which of these column names follows a clean syntax?",
    answer("date hospitalisation", message = "No spaces!"),
    answer("date_of_patient_hospitalisation", message = "This is a really long name..."),
    answer("date@hospitalisation", message = "No special characters!"),
    answer("date_hosp", correct = TRUE, message = "Yes, short and concise with no spaces or special characters."),
    allow_retry = TRUE
  ),
  question("Which of these functions can be used to rename columns?",
           answer("rename()", correct = TRUE),
           answer("clean_names()", correct = TRUE),
           answer("head()"),
           answer("select()", correct = TRUE),
    allow_retry = TRUE
           ),
  question("Why is it useful to follow a similar style nomenclature (all date columns starting *date_*) for column names?",
    answer("It looks good when you output tables and figures"),
    answer("It helps us find relevant columns and makes omissions/errors less likely", correct = TRUE),
    answer("R is very inflexible and only allows certain combinations of words"),
    answer("It allows us to sort the dataset by alphabetical order"),
    allow_retry = TRUE
  )
)
```


### Renaming exercise  

**In the codebox below, can you add a `rename()` command that does the following:**  

* Is linked to the `clean_names()` command with a pipe operator  
* Renames `onset_date` as `date_onset`  
* Renames `date_of_report` as `date_report`  
* Renames `adm3_name_res` as `district_res` (district of case residence)  
* Renames `adm3_name_det` as `district_det` (district of case detection)  

```{r rename, exercise=TRUE}
linelist <- linelist_raw %>% 
  clean_names()
```

```{r rename-hint}
Place a pipe operator after clean_names() and on a new line begin your rename() command
```

```{r rename-hint-2}
Within the recode command, list each change on it's own line followed by a comma (no comma for the last one)
```


```{r rename-hint-3}
linelist <- linelist_raw %>% 
  clean_names() %>% 
  rename(NEW = OLD,
         NEW = OLD,
         NEW = OLD,
         NEW = OLD)
```

```{r rename-solution, eval=FALSE}
linelist <- linelist_raw %>% 
  clean_names() %>% 
  rename(date_onset = onset_date,
         date_report = date_of_report,
         district_res = adm3_name_res,
         district_det = adm3_name_det)
```

```{r rename-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal(message =  "Excellent, you have cleaned the dataset as expected!")
    # Default to failing grade with feedback
    fail()
  })
```

Let's again use the `names()` function to see the new column names in the cleaned data frame `linelist`:  

```{r, eval=TRUE, echo=TRUE}
names(linelist)
```





## Printing vs. assignment commands  

It is worth pausing a moment to ensure that you understand the difference between an R command that *prints* an output, as compared to a command that *makes an assignment*.  

**The difference is the presence or absence of the assignment operator `<-`**  

If the assignment operator is present in a command, **no output is printed**, like in these three examples:  

```{r, eval=FALSE, echo=TRUE}
# import the data and assigns it to the name linelist_raw
linelist_raw <- import(here("data", "linelist.xlsx"))
```

```{r, eval=FALSE, echo=TRUE}
# cleans raw data, assigns the result to the clean linelist
linelist <- linelist_raw %>% 
  clean_names() %>% 
  rename(date_onset = onset_date,
         date_report = date_of_report,
         district_res = adm3_name_res,
         district_det = adm3_name_det) 
```

```{r, eval=FALSE, echo=TRUE}
# creates a new data frame of cases under age 18
cases_under18 <- linelist %>% 
  filter(age < 18)
```

In contrast, the following commands will *print* the output only (*not* save any changes), because there is no assignment operator:  

```{r, eval=TRUE, echo=TRUE}
# print the current column names of linelist
names(linelist)
```

```{r, eval=TRUE, echo=TRUE}
# modify linelist to show only certain rows and columns
# print the result
# note: linelist dataset is NOT permanently changed
linelist %>% 
  select(case_id, age, gender, case_def) %>% 
  filter(age > 65)
```


In particular, note this last example. The pipe operator is used to modify the `linelist` object, but the result is printed and there are no lasting changes made to the `linelist` data frame.  









## Select columns  


The `select()` function is versatile and used to:  

* Keep columns  
* Drop columns  
* Re-arrange columns  


### Select columns to keep  

The primary purpose of `select()` is to indicate which columns to keep in the dataset.  

Any column name that is not included in the parentheses will be dropped. The command below takes the partially-clean `linelist` data frame and selects only a few columns, printing (not saving) the result.  

```{r, echo=T, eval=TRUE}
linelist %>% 
  select(case_def, age, gender)
```

What did you notice about the new order of the columns? *`select()` also re-orders columns*.  


### Drop columns by name  

Use a minus symbol ( - ) to drop a column by name - all other columns are retained.  

```{r, echo=T, eval=F}
# remove a column by name
select(-case_def)
```

Try dropping multiple columns by wrapping all their names in a vector with `c()` - this applies the negative sign to all of them. We learned about the {base} function `c()` in the previous tutorial, which stands for "concatenate". Here it is used to create a vector of column names and the - minus sign is applied to all of them.  

```{r, echo=T, eval=F}
# removes these three columns
select(-c(case_def, district_det, age))

# an equivalent command to above
select(-case_def, -district_det, -age)
```


It may be taxing to list every column individually. Instead you can use "tidyselect" helper functions:  

For example, you can list some columns to move them to the beginning (left) of the data frame. Then write `everything()` to include all the other columns in their original order (note the empty parentheses at the end of `everything()`).  

```{r, echo=TRUE, eval=TRUE}
# move some columns to front (left) of data frame
linelist %>% 
  select(lat, lon, everything())
```

Some other "tidyselect" helpers:  

* `last_col()` - the last column  
* `where()` - applies a function to all columns and selects those which are true  
  * example: `select(where(is.numeric))`  
  * This would select all columns where the class is numeric  
* `contains()` - columns containing a character string that you provide  
  * example: `select(contains("time"))`  
* `starts_with()` and `ends_with()`- matches to a specified prefix  
  * example: `select(starts_with("date_"))`  
* `any_of()` - matches if the column exists, but returns no error if it is not found  
  * example: `select(any_of(date_onset, date_death, cardiac_arrest))`  

Read more about these helpers in this [Epi R Handbook chapter](https://epirhandbook.com/en/cleaning-data-and-core-functions.html#clean_tidyselect).  

You can also use a colon ( : ) to keep the two named columns and all those in between.  

```{r, echo=T, eval=F}
# keeps fever, vomit, and the columns in between them 
linelist %>% 
  select(fever:vomit)

# selects columns 1 though 5
linelist %>% 
  select(1:5)
```




`r fontawesome::fa("terminal", fill = "black")` Now time to code! In the codebox below, add a command to your pipe chain that removes the column `row_num` from the dataset. Remember because this command has the `<-` operator there will be no output. Check you result with the "Submit answer" button.  


```{r select, exercise=TRUE}
linelist <- linelist_raw %>% 
  clean_names() %>% 
  rename(date_onset = onset_date,
         date_report = date_of_report,
         district_res = adm3_name_res,
         district_det = adm3_name_det)
```

```{r select-hint}
Place a pipe operator after the close of rename() and on a new line begin your select() command
```

```{r select-hint-2}
Remove the row_num column with a minus symbol
```


```{r select-hint-3}
select(-row_num)
```

```{r select-solution, eval=FALSE}
linelist <- linelist_raw %>% 
  clean_names() %>% 
  rename(date_onset = onset_date,
         date_report = date_of_report,
         district_res = adm3_name_res,
         district_det = adm3_name_det) %>% 
  select(-row_num)
```

```{r select-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal(message =  "Excellent, you have cleaned the dataset and subset to the columns you want")
    # Default to failing grade with feedback
    fail()
  })
```


```{r, echo=FALSE, eval=TRUE}
# update the current "demo" data frame
demo <- linelist_raw %>% 
  clean_names() %>% 
  rename(date_onset = onset_date,
         date_report = date_of_report,
         district_res = adm3_name_res,
         district_det = adm3_name_det) %>% 
  select(-row_num)
```



Just for practice, can you write a command that *prints* the dataset `linelist`, but with only `case_id` and all the "date" columns

```{r startswith, exercise = TRUE}

```

```{r startswith-hint}
start with the linelist, then pipe to select()
```

```{r startswith-hint-2}
Within select() write case_id, then use `starts_with()` and then the `everything()` helper function
```

```{r startswith-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal(message = "You have correctly linked the functions in order and displayed the names of the cleaned dataset, good work!")
    # Default to failing grade with feedback
    fail()
  })
```

```{r startswith-solution}
linelist %>%
  select(case_id, starts_with("date_"), everything())
```








## Column creation and transformation

Creating new columns and transforming existing ones is easily done in R using the `mutate()` function from the {dplyr} package.  

`mutate()` uses the syntax NEW = TRANSFORMATION inside its parentheses. Let's show you a few examples:  


### Create a new, simple column  

The first thing to type within the parentheses is the *name of the column that you want to create or transform*.  

In perhaps the most simple example, the command below could be added to your pipe chain, and would create a new column called `new_col` where each row has the value of 10.  

```{r eval = F, echo = T}
mutate(new_col = 10)
```

However more often, we want the value in each row to reference the values in other columns, for that particular row. This can be done on the right side of the equals sign. For example, to calculate the Body Mass Index (BMI) we can use the formula BMI = kg/m^2 using the column `ht_cm` and `wt_kg` through:  

The command below begins with the cleaned `linelist`, uses `mutate()` to create the new column `bmi`, which will appear on the far right side of the data frame. To make it easier for you to see the new column, we then select only the three columns of interest before printing.  

```{r eval = T, echo = T}
linelist %>%                                   # start with the linelist
  mutate(bmi = wt_kg / (ht_cm / 100) ^ 2) %>%  # create new column bmi
  select(wt_kg, ht_cm, bmi)                    # print only a few columns
```


```{r rhetorical2, echo = FALSE}
question_text(
  "Can you think of a reason why we would create a new column in R, rather than in the CSV or Excel?",
  answer_fn(function(value) {
    if (grepl(paste(letters, collapse = "|"), value)) {
      correct("")
    }
  }, )
)
```


```{r quiz2}
quiz(
  question("Which function can be used to create new columns?",
    answer("select()"),
    answer("mutate()", correct = TRUE),
    answer("rename()"),
    answer("clean_names()"),
    allow_retry = TRUE
  ))
```



### Using functions to modify columns  


`mutate()` can also be used on existing columns. This is often to modify them in some way, which can also be thought of as "re-defining" the values in the column.  

The right side of the `mutate()` equals sign is often a *function*. The function will look at values in each row, and return some output to the existing/new column based on those other values.  

> mutate(**column name** = *a function* used to create/modify the column's values) 


```{r, results = "asis", echo = FALSE}
"mutate(column name = a function used to create/modify the column's values)" %>%
  flair("column name", color = "deeppink") %>%
  flair("a function", color = "cornflowerblue") %>%
  flair_all(before = "<h4>", after = "</h4>") %>%
  cat()
```

The function `ifelse()` is a simple, flexible tool that evaluates a logical statement for each row in the data frame, and provides either one value or another. It has the following arguments:  

1) `test = ` Provide a logical statement that evaluates to either `TRUE` or `FALSE` for each row  
2) `yes = `  Provide what should be written in the column for this row, if the statement evaluates to `TRUE`  
3) `no = `   Provide what should be written in the column for this row, if the statement evaluates to `FALSE`  

The `ifelse()` function can be used *within* a `mutate()` command as shown below:  

```{r mutate, include = F}
demo %>% 
  mutate(adult = ifelse(age >= 18, TRUE, FALSE)) # creates new T/F column
```

```{r mutate_flair, echo=F}
decorate("mutate") %>%
  flair("adult", color = "deeppink") %>%
  flair("ifelse", color = "cornflowerblue") %>% 
  knit_print.with_flair()
```

Click to see the new right-most column `adult` that was created by this command. 



### Cleaning negative weights  

```{r, eval=FALSE, echo=TRUE}
summary(linelist$wt_kg)
```

```{r, eval=TRUE, echo=FALSE}
demo <- linelist_raw %>%
  clean_names() %>%
  rename(date_onset = onset_date)

summary(demo$wt_kg)
```

If we look at the values of `linelist` in its current state, there are some weights in the column `wt_kg` that are negative - clearly some error in the data entry. **We want to convert negative weight values to `NA` (R's symbol for "missing").**  

Here is a `mutate()` command that is modifying the existing column `wt_kg`. If the value in a row is negative, the value is changed to `NA`, otherwise it stays as the original value for that row.  

```{r, echo=TRUE, eval=FALSE}
mutate(wt_kg = ifelse(test = wt_kg < 0, yes = NA, no = wt_kg))
```

You can also write this command vertically, if it is easier for you to read:  

```{r, echo=TRUE, eval=FALSE}
mutate(wt_kg = ifelse(test = wt_kg < 0,
                      yes = NA,
                      no = wt_kg))
```


**Now add this `mutate()` command to the bottom of the pipe chain, so that it is properly recorded in our sequence of steps.**

```{r mutate-wt, exercise=TRUE}
linelist <- linelist_raw %>% 
  clean_names() %>% 
  rename(date_onset = onset_date,
         date_report = date_of_report,
         district_res = adm3_name_res,
         district_det = adm3_name_det) %>% 
  select(-row_num)
```

```{r mutate-wt-hint}
Place a pipe operator after the close of select() and on a new line begin your mutate() command
```

```{r mutate-wt-hint-2}
Within the mutate() write the name of the column to change, then the ifelse() function
```


```{r mutate-wt-hint-3}
mutate(wt_kg = ifelse(test = wt_kg < 0, yes = NA, no = wt_kg))
```

```{r mutate-wt-solution, eval=FALSE}
linelist <- linelist_raw %>%
            clean_names() %>% 
            rename(date_onset = onset_date,
                   date_report = date_of_report,
                   district_res = adm3_name_res,
                   district_det = adm3_name_det) %>% 
            select(-row_num) %>% 
            mutate(wt_kg = ifelse(test = wt_kg < 0, yes = NA, no = wt_kg))
```

```{r mutate-wt-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal(message =  "Excellent, you have cleaned column wt_kg as expected.")
    # Default to failing grade with feedback
    fail()
  })
```

Now we can look at that `summary()` command again, and see that the minimum value is a positive number, and there are now a few `NA` values.  

```{r, eval=TRUE, echo=TRUE}
summary(linelist$wt_kg)
```

```{r, echo=FALSE, eval=TRUE}
# update the current "demo" data frame
demo <- linelist_raw %>%
            clean_names() %>% 
            rename(date_onset = onset_date,
                   date_report = date_of_report,
                   district_res = adm3_name_res,
                   district_det = adm3_name_det) %>% 
            select(-row_num) %>% 
            mutate(wt_kg = ifelse(test = wt_kg < 0, yes = NA, no = wt_kg))
```









### Changing column class    

Each column in a data frame has a "class". In fact, each object in R has a "class" (e.g. a "data frame" is a class as well). But most often we are concerned with the class of columns, so that their values are handled by R appropriately.  

As a reminder, common classes of columns include:  

* "Character" - these are words, with the values written within quotation marks  
* "Numeric" - Numbers that can include decimal places  
* "Integer" - Numbers that can only be whole numbers (no decimals)  
* "Date" - Recognized by R as a date  
* "Logical" - The values are either `TRUE` or `FALSE`  

One very common task is to convert the "class" of a column from "character" to "Date", so that its date values are properly recognized by R, enabling the creation of epidemic curves, date calculations, etc.  

The column `date_onset` is currently recognized as "character" by R, meaning that R is thinking about "10/20/2014" as simply a "word" - not as meaning any particular date.    

```{r, eval=FALSE, echo=TRUE}
class(linelist$date_onset)
```

```{r, eval=TRUE, echo=FALSE}
class(demo$date_onset)
```

Dates in R are a significant topic and are covered in depth in this Epi R Handbook [chapter](https://epirhandbook.com/en/working-with-dates.html), but we will give an overview here.  

First, we need to understand **how the date is *currently written* in the data before we make the change**.  

```{r, eval=FALSE, echo=TRUE}
linelist
```

```{r, eval=TRUE, echo=FALSE}
demo
```

```{r quiz-date-format-raw}
quiz(caption = "Quiz - raw date format",
  question("Which format is date_onset??",
    allow_retry = T,
    answer("YYYY-MM-DD"),
    answer("DD/MM/YYYY"),
    answer("MM/DD/YYYY", correct = T)
  )
)
```

Then, within a `mutate()` command, we use one of the 3 {lubridate} functions below to transform the column to class "Date".  

* `ymd()` - if the *current* format is Year Month Day
* `mdy()` - if the *current* format is Month Day Year  
* `dmy()` - if the *current* format is Day Month Year  


**The reason for this is simple**: if we try to tell R to convert "02/03/2014" to a date, *it will not know whether the date is 3rd of February, or 2nd of March*. We have to tell R the *current* (old) format.  

These {lubridate} functions are very forgiving: it does not matter the separator between the date parts, e.g. - / or space, it also does not matter if month is written as 01, Jan, or January:  

The `ymd()` function converts character values to date class that are written as: year, month, day.  

```{r, echo=TRUE}
ymd("2020-10-11") 
ymd("20201011")
```


The `mdy()` does the same but for values written as month, day, year.  

```{r, echo=TRUE}
mdy("Oct 11 2020")
mdy("10/11/2020") 
```

and `dmy()` for values written as day, month, year  

```{r, echo=TRUE}
dmy("11 October 2020") 
dmy("11/10/2020")
```


Once R converts the column to dates, it will display it in the data in the "standard" date format YYYY-MM-DD. **In ALL of the above commands, the *outcome* is values in date class that display as YYYY-MM-DD.**  

```{r quiz-date-format}
quiz(caption = "Quiz - date format",
  question("Which function should be used to convert the column date_onset?",
    allow_retry = T,
    answer("ymd()"),
    answer("dmy()"),
    answer("mdy()", correct = T)
  )
)
```

Thus, the command to add to our pipe chain to modify the column `date_onset` to be converted to class "date" would look like this:  

```{r, eval = F, echo = T}
mutate(date_onset = mdy(date_onset))
```


Above, the code is in effect saying: "change (mutate) the values in the `date_onset` column, such that they become the current `date_onset` column as interpreted by the function `mdy()`."  

**Now add two `mutate()` commands to the pipe chain, that convert `date_onset` and `date_report` to class "date".**  

```{r mutate-date, exercise=TRUE}
linelist <- linelist_raw %>% 
  clean_names() %>% 
  rename(date_onset = onset_date,
         date_report = date_of_report,
         district_res = adm3_name_res,
         district_det = adm3_name_det) %>% 
  select(-row_num) %>% 
  mutate(wt_kg = ifelse(test = wt_kg < 0, yes = NA, no = wt_kg))
```

```{r mutate-date-hint}
Add a pipe operator and begin with a new mutate() command on a new line
```

```{r mutate-date-hint-2}
Within the mutate() write the name of the column to change, then the date conversion function, wrapped around the column name
```

```{r mutate-date-hint-3}
mutate(date_onset = mdy(date_onset)) %>% 
mutate(date_report = mdy(date_report))
```

```{r mutate-date-solution, eval=FALSE}
linelist <- linelist_raw %>% 
  clean_names() %>% 
  rename(date_onset = onset_date,
         date_report = date_of_report,
         district_res = adm3_name_res,
         district_det = adm3_name_det) %>% 
  select(-row_num) %>% 
  mutate(wt_kg = ifelse(test = wt_kg < 0, yes = NA, no = wt_kg)) %>% 
  mutate(date_onset = mdy(date_onset)) %>% 
  mutate(date_report = mdy(date_report))
```

```{r mutate-date-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal(message =  "Excellent, you have cleaned the dataset as expected!")
    # Default to failing grade with feedback
    fail()
  })
```



Now we can inspect the date column, and use it in plotting functions like a continuous variable. Previously, as class character, a plot like the one created below would not have been possible.  

We give you this code below not to learn plotting, but simply to see the outcome. You will learn how to make plots with {ggplot2} later in the course.  

```{r, echo=TRUE, eval=TRUE, warning=F, message=F}
# plot a histogram of dates using the cleaned dataset and date column
ggplot(data = linelist, mapping = aes(x = date_onset))+
  geom_histogram()

```


```{r quiz-dates}
quiz(caption = "Quiz - Date",
  question("In the most recent weeks, what is the apparent trend in the number of reported cases?",
    allow_retry = T,
    answer("Increasing"),
    answer("Decreasing", correct = T)
  )
)
```


You can use the function `as.character()` to convert to class "character", `as.numeric()` to convert to class "numeric", and there is also a function `as.Date()` although we recommend the approach above to convert to "date" if you are just now learning R.  








### Coding style  

It is worth pointing out that you can combine multiple mutate statements into one `mutate()` command. Simply separate the statements by commas.  

Our cleaning pipe chain currently has 3 mutate commands at the end, separated by pipe operators.  

```{r, eval=FALSE}
linelist <- linelist_raw %>% 
  clean_names() %>% 
  rename(date_onset = onset_date,
         date_report = date_of_report,
         district_res = adm3_name_res,
         district_det = adm3_name_det) %>% 
  select(-row_num) %>% 
  mutate(wt_kg = ifelse(test = wt_kg < 0, yes = NA, no = wt_kg)) %>% 
  mutate(date_onset = mdy(date_onset)) %>% 
  mutate(date_report = mdy(date_report))
```

This can also be written as:  

```{r, eval=FALSE}
linelist <- linelist_raw %>% 
  clean_names() %>% 
  rename(date_onset = onset_date,
         date_report = date_of_report,
         district_res = adm3_name_res,
         district_det = adm3_name_det) %>% 
  select(-row_num) %>% 
  mutate(wt_kg = ifelse(test = wt_kg < 0, yes = NA, no = wt_kg), 
         date_onset = mdy(date_onset),
         date_report = mdy(date_report))
```

If you are just learning R, you may choose to write distinct `mutate()` commands for each step, to avoid accidentally making a mistake (e.g. forgetting a comma). Both approaches will work. Do remember though the order of events - it may be to your advantage to have a few `mutate()` commands in your chain, if you need to do other steps in between.  



#### Be nice to your future readers  

While we are on the topic of style for pipe chains, remember that if writing a proper R script it is best to thoroughly comment your code for future readers (including yourself!):  


```{r, eval=FALSE}
linelist <- linelist_raw %>% 
  
  # standardize column syntax
  clean_names() %>% 
  
  # manually rename columns
  rename(
    date_onset = onset_date,            # list date first
    date_report = date_of_report,       # standardize
    district_res = adm3_name_res,       # simplify
    district_det = adm3_name_det) %>%   # simplify
  
  # remove unnecessary column
  select(-row_num) %>% 
  
  # clean existing columns
  mutate(
    
    # clean weight
    wt_kg = ifelse(
      test = wt_kg < 0,    # if weight is negative
      yes = NA,            # convert to missing
      no = wt_kg),         # else keep original value
    
    # clean date of onset
    date_onset = mdy(date_onset),   # convert to date
    
    # clean date of report
    date_report = mdy(date_report)) # convert to date
```


Vertical space is your ally! It makes it much easier to read and understand code.  




## Deduplication  


The function `distinct()` from the package {dplyr} is useful for quick de-duplication of records.  

If any rows are 100% identical (all columns), then `distinct()` will keep only one of them.  

`distinct()` can also be used in more nuanced ways, such as to only consider certain columns when evaluating duplicates (e.g. rows that have the same age, gender, and first name). You can read in its [documentation](https://dplyr.tidyverse.org/reference/distinct.html), and in the [Epi R Handbook cleaning chapter](https://epirhandbook.com/en/cleaning-data-and-core-functions.html#deduplication). In fact, there is an entire chapter of the Epi R Handbook dedicated to [de-duplication](https://epirhandbook.com/en/de-duplication.html) that we encourage you to read if you do a lot of record de-duplication.   


Below, we add a simple, empty `distinct()` command to our cleaning pipe chain, to deduplicate rows that are 100% identical:  


```{r, echo = T, eval = T}
linelist <- linelist_raw %>% 
  clean_names() %>% 
  rename(date_onset = onset_date,
         date_report = date_of_report,
         district_res = adm3_name_res,
         district_det = adm3_name_det) %>% 
  select(-row_num) %>% 
  mutate(wt_kg = ifelse(test = wt_kg < 0, yes = NA, no = wt_kg)) %>% 
  mutate(date_onset = mdy(date_onset)) %>% 
  mutate(date_report = mdy(date_report)) %>% 
  distinct()
```

```{r, echo = FALSE, eval = TRUE}
demo <- linelist_raw %>% 
  clean_names() %>% 
  rename(date_onset = onset_date,
         date_report = date_of_report,
         district_res = adm3_name_res,
         district_det = adm3_name_det) %>% 
  select(-row_num) %>% 
  mutate(wt_kg = ifelse(test = wt_kg < 0, yes = NA, no = wt_kg)) %>% 
  mutate(date_onset = mdy(date_onset)) %>% 
  mutate(date_report = mdy(date_report)) %>% 
  distinct()
```

```{r, eval = FALSE, echo=TRUE}
nrow(linelist)
```

```{r, eval = TRUE, echo=FALSE}
nrow(demo)
```

As you can see, there are `r nrow(linelist_raw) - nrow(demo)` rows that were dropped from the original `r nrow(linelist_raw)`.  








## Prioritizing values  


The `coalesce()` function from {dplyr} allows us to "fill in" missing values with the first available value in an order you specify. In this way, you can say "use X if it is present, otherwise use Y". This can be very helpful in public health datasets.  
 
Here is a mini-example using a data frame called `case_locations`:  

```{r, echo=TRUE, eval=TRUE}
# create the demo dataset
case_locations <- data.frame(
  detection = c("Ankara", "Gaziantep", NA,  "Ankara"),
  residence = c("Istanbul", "Gaziantep", "Istanbul", NA))

# print the demo dataset
case_locations
```

Let's say that we want to make a GIS map of the cases by city - for the mapping we would prefer to use the city of detection, but some are missing. In those cases we want to use city of residence. If we were to modify the data frame with `mutate()` to add a column called `map_location`, it might look as below.  

We create the column `map_location`, and use `coalesce()` such that the city of detection (if it exists) is prioritized over the city of residence:  

```{r, echo=TRUE, eval=TRUE}
# re-define case_locations data frame with extra column
case_locations <- case_locations %>% 
  mutate(map_location = coalesce(detection, residence))

# print data frame
case_locations
```


In our `linelist` data frame, we have data on the geographic district the case was detected in (`district_det`), and also on the district of the case's residence (`district_res`).  

Add a command to our pipe chain using `coalesce()` to create a new column `district` that prioritizes district of detection over district of residence:


```{r coalesce, exercise=TRUE}
linelist <- linelist_raw %>% 
  clean_names() %>% 
  rename(date_onset = onset_date,
         date_report = date_of_report,
         district_res = adm3_name_res,
         district_det = adm3_name_det) %>% 
  select(-row_num) %>% 
  mutate(wt_kg = ifelse(test = wt_kg < 0, yes = NA, no = wt_kg)) %>% 
  mutate(date_onset = mdy(date_onset)) %>% 
  mutate(date_report = mdy(date_report)) %>% 
  distinct()
```

```{r coalesce-hint}
Add a pipe operator and begin with a new mutate() command on a new line
```

```{r coalesce-hint-2}
Within the mutate() write the name of the new column, an equals, then the coalesce function
```

```{r coalesce-hint-3}
mutate(district = coalesce(district_det, district_res))
```

```{r coalesce-solution, eval=FALSE}
linelist <- linelist_raw %>% 
  clean_names() %>% 
  rename(date_onset = onset_date,
         date_report = date_of_report,
         district_res = adm3_name_res,
         district_det = adm3_name_det) %>% 
  select(-row_num) %>% 
  mutate(wt_kg = ifelse(test = wt_kg < 0, yes = NA, no = wt_kg)) %>% 
  mutate(date_onset = mdy(date_onset)) %>% 
  mutate(date_report = mdy(date_report)) %>% 
  distinct() %>% 
  mutate(district = coalesce(district_det, district_res))

```

```{r coalesce-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal(message =  "Excellent, you have cleaned the dataset as expected!")
    # Default to failing grade with feedback
    fail()
  })
```






### Missing values  

As identified earlier, in the column `gender` in the original `linelist_raw` data frame there is the character value "Unknown".  

```{r, echo=T}
linelist_raw %>% 
  tabyl(gender)
```

There are some analyses in our future for which we want "missing" values in this column to be properly coded as `NA`, not as the character "Unknown". For example, making age/sex pyramids are easier with missing values coded this way.  

You already know one tool that can fix this problem - `ifelse()`.

What would your `mutate()` command look like if you used `ifelse()` to convert "Unknown" to `NA`?  

```{r ifelse-gender, exercise = TRUE}
linelist %>% 
  mutate(___)
```



```{r ifelse-gender-hint}
Within the mutate() the name of the column to modify, then equals, then the ifelse function
```

```{r ifelse-gender-hint-2}
The ifelse function has three arguments: the test, the yes value, and the no value
```

```{r ifelse-gender-hint-3}
mutate(gender = ifelse(gender == "Unknown", NA, gender))
```

```{r ifelse-gender-solution, eval=FALSE}
linelist %>% 
  mutate(gender = ifelse(gender == "Unknown", NA, gender))
```

```{r ifelse-gender-check}
gradethis::grade_this_code("Yes, good memory!")
```

Note how in the solution, the arguments of `ifelse()` did not have their names (test, yes, and no). As long as the arguments are written in the expected order, you do not need to specify their names.  

#### {dplyr} helper functions  

{dplyr} and {tidyr} offer two other helpful functions to know: `na_if()` and `replace_na()`. These are simple functions - they simply switch a single character value with `NA`.  

Thus, in the above scenario, you could write instead:  

```{r, echo=TRUE, eval=FALSE}
mutate(gender = na_if(gender, "Unknown"))
```

You can read more about [na_if()](https://dplyr.tidyverse.org/reference/na_if.html) and [replace_na()](https://tidyr.tidyverse.org/reference/replace_na.html).


Our pipe chain now looks like this:  

```{r, eval=FALSE, echo=TRUE}
linelist <- linelist_raw %>% 
  clean_names() %>% 
  rename(date_onset = onset_date,
         date_report = date_of_report,
         district_res = adm3_name_res,
         district_det = adm3_name_det) %>% 
  select(-row_num) %>% 
  mutate(wt_kg = ifelse(test = wt_kg < 0, yes = NA, no = wt_kg)) %>% 
  mutate(date_onset = mdy(date_onset)) %>% 
  mutate(date_report = mdy(date_report)) %>% 
  distinct() %>% 
  mutate(district = coalesce(district_det, district_res)) %>% 
  mutate(gender = na_if(gender, "Unknown"))
```

```{r, eval=TRUE, echo=FALSE}
#Update demo at this point in time
demo <- linelist_raw %>% 
  clean_names() %>% 
  rename(date_onset = onset_date,
         date_report = date_of_report,
         district_res = adm3_name_res,
         district_det = adm3_name_det) %>% 
  select(-row_num) %>% 
  mutate(wt_kg = ifelse(test = wt_kg < 0, yes = NA, no = wt_kg)) %>% 
  mutate(date_onset = mdy(date_onset)) %>% 
  mutate(date_report = mdy(date_report)) %>% 
  distinct() %>% 
  mutate(district = coalesce(district_det, district_res)) %>% 
  mutate(gender = na_if(gender, "Unknown"))
```











## Simple recoding  

Values are often entered in data inconsistently, and must be "cleaned". In other scenarios, you simply want to re-code values to make them more concise. Either way, if the switches are simple you can use the `recode()` function within a `mutate()` command to do the job.  

For instance, to fix a date that has been incorrectly written we can use the following (note that the old value in this case is an impossible date):

```{r, echo = TRUE, eval = FALSE}
linelist %>%                             #Old value     #New value
  mutate(date_onset = recode(date_onset, "15/14/2014" = "15/04/2014"))
```

Why make this change in code? Why not just go back to the Excel file and make the change there?  

**This way, you have a record** - your work is now transparent and reproducible by others. You can discuss your script with your team and decide if they agree with you. And moreover, you do not have to do it all over again when you receive an updated linelist with new cases!  



### Re-coding hospital names  

Now we turn to the column `hospital`. Again, the `tabyl()` function can be used to create a simple tabulation of all the values in this column:  

```{r, echo=T, eval=F}
linelist %>% 
  tabyl(hospital)
```

```{r, echo=FALSE, eval=TRUE}
demo %>% 
  tabyl(hospital)
```

It seems there is some cleaning to be done! Note the different spellings of "hospital" and "hopital", of "Military" and "Mitilary", and of "Port" and "Port Hospital". These need to be synchronized.  

An easy option is `recode()`. The syntax is relatively simple when we want to simply exchange one value for another:  

```{r, echo=T, eval=F}
linelist %>% 
  mutate(hospital = recode(hospital,
    "OLD value" = "NEW value",
    "OLD value" = "NEW value",
    "OLD value" = "NEW value"))
```

The above code can be read as: "Re-define `hospital` as `hospital` with these recodings applied".  

**Note that unlike `rename()`, `recode()` is used within a `mutate()` function**. It also uses the *opposite* syntax (old = new, instead of new = old).  

**Now, add a command to the pipe chain that aligns all the hospital names to the following:**  

* Military Hospital  
* Port Hospital  
* Central Hospital
* SMMH
* Other  

**To preserve the original values, save the result in a new column `hospital_clean`.**  


```{r recode, exercise=TRUE}
linelist <- linelist_raw %>% 
  clean_names() %>% 
  rename(date_onset = onset_date,
         date_report = date_of_report,
         district_res = adm3_name_res,
         district_det = adm3_name_det) %>% 
  select(-row_num) %>% 
  mutate(wt_kg = ifelse(test = wt_kg < 0, yes = NA, no = wt_kg)) %>% 
  mutate(date_onset = mdy(date_onset)) %>% 
  mutate(date_report = mdy(date_report)) %>% 
  distinct() %>% 
  mutate(district = coalesce(district_det, district_res)) %>% 
  mutate(gender = na_if(gender, "Unknown"))
```

```{r recode-hint}
Within the mutate() write the name of the new column, an equals, then the recode() function
```

```{r recode-hint-2}
mutate(hospital_clean = recode(hospital,
  OLD = NEW,
  OLD = NEW))
```

```{r recode-hint-3}
linelist <- linelist_raw %>% 
  clean_names() %>% 
  rename(date_onset = onset_date,
         date_report = date_of_report,
         district_res = adm3_name_res,
         district_det = adm3_name_det) %>% 
  select(-row_num) %>% 
  mutate(wt_kg = ifelse(test = wt_kg < 0, yes = NA, no = wt_kg)) %>% 
  mutate(date_onset = mdy(date_onset)) %>% 
  mutate(date_report = mdy(date_report)) %>% 
  distinct() %>% 
  mutate(district = coalesce(district_det, district_res)) %>% 
  mutate(gender = na_if(gender, "Unknown")) %>% 
  mutate(hospital_clean = recode(hospital,
    "Mitilary Hospital"  = "Military Hospital",
    "Port"               = "Port Hospital",
    "Port Hopital"       = "Port Hospital",
    "St. Mark's Maternity Hospital (SMMH)" = "SMMH"))
```

```{r recode-solution, eval=FALSE}

linelist <- linelist_raw %>% 
  clean_names() %>% 
  rename(date_onset = onset_date,
         date_report = date_of_report,
         district_res = adm3_name_res,
         district_det = adm3_name_det) %>% 
  select(-row_num) %>% 
  mutate(wt_kg = ifelse(test = wt_kg < 0, yes = NA, no = wt_kg)) %>% 
  mutate(date_onset = mdy(date_onset)) %>% 
  mutate(date_report = mdy(date_report)) %>% 
  distinct() %>% 
  mutate(district = coalesce(district_det, district_res)) %>% 
  mutate(gender = na_if(gender, "Unknown")) %>% 
  mutate(hospital_clean = recode(hospital,
    "Mitilary Hospital"  = "Military Hospital",
    "Port"               = "Port Hospital",
    "Port Hopital"       = "Port Hospital",
    "St. Mark's Maternity Hospital (SMMH)" = "SMMH"))
```

```{r recode-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal(message =  "Excellent, you have cleaned the dataset as expected!")
    # Default to failing grade with feedback
    fail()
  })
```

```{r, eval=TRUE, echo=FALSE}
#Update demo at this point in time
demo <- linelist_raw %>% 
  clean_names() %>% 
  rename(date_onset = onset_date,
         date_report = date_of_report,
         district_res = adm3_name_res,
         district_det = adm3_name_det) %>% 
  select(-row_num) %>% 
  mutate(wt_kg = ifelse(test = wt_kg < 0, yes = NA, no = wt_kg)) %>% 
  mutate(date_onset = mdy(date_onset)) %>% 
  mutate(date_report = mdy(date_report)) %>% 
  distinct() %>% 
  mutate(district = coalesce(district_det, district_res)) %>% 
  mutate(gender = na_if(gender, "Unknown")) %>% 
  mutate(hospital_clean = recode(hospital,
    "Mitilary Hospital"  = "Military Hospital",
    "Port"               = "Port Hospital",
    "Port Hopital"       = "Port Hospital",
    "St. Mark's Maternity Hospital (SMMH)" = "SMMH"))
```



Now we can re-run the `tabyl()` command to see if the values were changed as we expected:  

```{r, echo=T, eval=F}
linelist %>% 
  tabyl(hospital_clean)
```

```{r, echo=FALSE, eval=TRUE}
demo %>% 
  tabyl(hospital_clean)
```

You can even cross-tabulate with `tabyl()` to see how the old values (in the rows) compare to the new values (in the columns). We will teach you more advanced tabling techniquies with `tabyl()` in a different tutorial.  

```{r, eval=FALSE, echo=TRUE}
linelist %>% 
  tabyl(hospital, hospital_clean)
```




## Complex recoding  

Simple logical re-coding you have already learned - you can use `ifelse()` for most things. Here are two others you can read about later:  

* [`if_else()`](https://dplyr.tidyverse.org/reference/if_else.html) is particularly useful if re-coding dates  
* [`replace()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/replace) can be a shortcut for `ifelse()` logical recoding  
But for more complex re-coding, you will likely switch to using [`case_when()`](https://dplyr.tidyverse.org/reference/case_when.html) from {dplyr}.  

This function allows you to run the equivalent of multiple `ifelse()` statements in a series - it is R's equivalent to the SQL `CASE WHEN` statement.  

It is just a coincidence that the `case_when()` function has a name that sounds like it was made for building case definitions! It is a general function - it is not specific to public health. Still, here is a demonstration of a `case_when()` command, used within `mutate()`, to create a case definition column:  

```{r, echo=TRUE, eval = TRUE}
linelist <- linelist %>% 
  mutate(case_def = case_when(
    lab_confirmed == TRUE             ~ "Confirmed case",
    epilink == "yes" & fever == "yes" ~ "Suspect case",
    TRUE                              ~ "To investigate"))
```

Within the `case_when()` function, you can write multiple two-sided formulas, one on each line for clarity.  

* Each formula has a *left* side, and a *right* side, separated by a tilde ~  
* The *left* side is a logical statement that can evaluate to `TRUE` or `FALSE` for a given row in the data  
  * You can reference other columns in these logical statements  
* The *right* side is the value that is used if the *left* side is `TRUE` for a given row  
  * **Importantly**, all values on the *right* side must be of the same class (e.g. either character, numeric, integer, etc.)  
  
Every row in the data frame is evaluated for each of these formulae, starting from the top and working to the last one. The first one that evaluates to `TRUE` for that row is used. **Therefore, it is very important to write the formulae in an intentional order - typically from very specific (at the top) to very broad (at the bottom)**.   

If none of the statements apply to a row in the data, that row is assigned `NA` by default, unless a `TRUE` statement is written as the last statement, as shown above. If last *left* side is `TRUE`, this catches any other situation that has not triggered one of the above logical statements.  

In the case definition example above, if a case is lab confirmed they are immediately categorized as a "Confirmed case". If lab confirmation is `FALSE` or missing, then if they have an epidemiologic link and a fever they are categorized as a "Suspect case". Finally, any row that has not met either of those criteria is marked as "To investigate".  

Now we can tabulate the new column `case_def` and see the results :

```{r, echo=TRUE, eval = TRUE}
linelist %>% 
  tabyl(case_def)
```

It is also wise to go look at the dataset to confirm that the logic was applied the way that you intended!  


### Make age in years  

Use what you learned about `case_when()`, and write a command that creates a column `age_years`, and which converts the value in `age` correctly, depending on whether the value in `age_unit` is "years" or "months".  


```{r casewhen1, exercise=TRUE}
linelist <- linelist %>% 
  mutate(age_years = case_when(
    # write logic             # make age_years   # tip
    if age_unit is months   ~ calculation here,  # divide age by 12 
    if age_unit is years    ~ calculation here,  # age 
    if age_unit is missing  ~ age,               # assume years
```

```{r casewhen1-hint}
replace the left sides with logic statements such as age_unit == "years"
```

```{r casewhen1-hint-2}
replace the right sides with calculations such as age/12
```

```{r casewhen1-hint-3}
linelist <- linelist %>%
  mutate(age_years = case_when(
    age_unit == "years"  ~ age,
    age_unit == "months" ~ age/12,
    is.na(age_unit)      ~ age))
```

```{r casewhen1-solution, eval=FALSE}
linelist <- linelist %>%
  mutate(age_years = case_when(
    age_unit == "years"  ~ age,
    age_unit == "months" ~ age/12,
    is.na(age_unit)      ~ age))
```

```{r casewhen1-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal(message =  "Excellent, you have cleaned the dataset as expected!")
    # Default to failing grade with feedback
    fail()
  })
```


```{r, eval=TRUE, echo=FALSE}
# register the change in the dataset
linelist <- linelist %>%
  mutate(age_years = case_when(
    age_unit == "years"  ~ age,
    age_unit == "months" ~ age/12,
    is.na(age_unit)      ~ age))
```







### Correct temperatures

Let us look at the temperatures of the case that are recorded in the `linelist` data frame. 

Thanks to this visualization, we can see that there is some discordance in the dataset.  

```{r, echo = TRUE, eval = TRUE, error = FALSE, warning=FALSE}
ggplot(data = linelist_raw) +
    geom_histogram(aes(x = temp), binwidth = 1) +
    scale_x_continuous(
      limits = c(30, 110),
      breaks = seq(from = 30, to = 110, by = 10)) +
    labs(
      x = "Temperature",
      y = "Count")
```

Most of the values are located between 35 and 41, as expected if we were recording temperatures in °C, however some values are around 100, and so we can deduce that these have been incorrectly recorded in °F. Using the formula, `°C = (°F − 32) * 5/9`, can you use complex logic to convert values that are above 90 and below 120 to Celcius? If the temperature is correctly recorded in °C, make sure it is not converted to `NA`!

```{r temp_convert_logic, exercise = TRUE}
linelist <- linelist %>%
  mutate(___)
```

```{r temp_convert_logic-hint}
You will need to use case_when() and greater than (temp >) and less than (temp <) combined with the and (&)
```

```{r temp_convert_logic-hint-2}
Your last line will need to be TRUE ~ temp so that all other values are not set to NA
```

```{r temp_convert_logic-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal(message = "You've successfully used complex logic, great work.")
    # Default to failing grade with feedback
    fail()
  })
```

```{r temp_convert_logic-solution}
linelist %>%
    mutate(temp = case_when(
      temp > 90 & temp < 120 ~ (temp - 32) * 5/9,
      TRUE                   ~ temp))
  
```



### Create categories from numeric columns


Now that we have cleaned the ages, and have a column `age_years', we want to create age groups. 

There are numerous reasons why you may want to creating groupings of numeric values such ages, lab values, etc. R offers several ways of doing this.

* `age_categories()`, from the {epikit} package  
* `case_when()` as you have already learned  
* alternatives such as `cut()` from {base}, or `quantile()` and `ntile()`  

Here we will show what we believe is the easiest of these techniques: `age_categories()`.  


### `age_categories()`

The `age_categories()` function easily categorizes and label numeric columns. This function can be applied to non-age numeric variables too. As a bonus, the values in the output column automatically have an intrinsic order, which in R is called being of class "factor".  

Here are the required inputs:

* A numeric vector (a column)
* A specification of how to create the groups, either:  
  * The `breakers = ` argument, providing a numeric vector of break points for new groups, OR  
  * The `lower = `, `upper = `, and `by = ` arguments  
  
Here is an example using the `breakers = ` argument. The column `age_cat` is being created, using the `age_categories()` function, from the `age_years` column.  

```{r, echo = T, eval = T}
linelist <- linelist %>% 
  mutate(age_cat = age_categories(age_years,  
      breakers = c(0, 5, 10, 15, 20, 30, 40, 50, 60, 70)))

# Print a table
linelist %>% tabyl(age_cat)
```

By default, the break values that you specify are the *lower* bounds, so that the left/lower side is "open" and "inclusive". You may also want to set an upper limit using `ceiling = TRUE`, which will categorize any value above the last breaker as `NA`.  

```{r, echo = T, eval = T}
linelist <- linelist %>% 
  mutate(age_cat = age_categories(age_years,
      breakers = c(0, 5, 10, 15, 20, 30, 40, 50, 60, 70),
      ceiling = TRUE))

# Print a table
linelist %>% tabyl(age_cat)
```

Alternatively, instead of using `breakers = ` you can provide `lower = `, `upper = ` and `by = `. Here we also show how you can adjust how the labels are displayed with `separator = `, for which the default is "-".

```{r, echo = T, eval = T}
linelist <- linelist %>% 
  mutate(age_cat = age_categories(age_years,
      lower = 0,
      upper = 70,
      by = 5,
      separator = " to "))

# Print a table
linelist %>% tabyl(age_cat)
```

There are many other variations to this tool, including combining months and years into appropriate categories. You can read more about it, and the other tools mentioned above, in the [age_categories() documentation](https://r4epi.github.io/epikit/) and in the [Data cleaning chapter](https://epirhandbook.com/en/cleaning-data-and-core-functions.html) of the Epi R Handbook. T  



```{r quiz5}
quiz(
  question("Which of these age_categories() specifications would create breaks at 0, 25, 50 and 75?",
    answer("age_categories(age_years, breakers = c(0, 25, 50, 75))", correct = TRUE),
    answer("age_categories(age_years, lower = 0, upper = 75, by = 5)", correct = TRUE),
    answer("age_categories(age_years, breakers = c(0, 25, 50, 75), ceiling = FALSE", correct = TRUE),
    answer("age_categories(age_years, breakers = 25, lower = 0, upper  = 75)")
  ))
```




### Add to pipe chain  

When these last `mutate()` commands are added to our cleaning pipe chain, it looks like this:  

```{r, echo=TRUE, eval=TRUE}
linelist <- linelist_raw %>% 
  
  # standardize column syntax
  clean_names() %>% 
  
  # manually rename columns
  rename(
    date_onset = onset_date,            # list date first
    date_report = date_of_report,       # standardize
    district_res = adm3_name_res,       # simplify
    district_det = adm3_name_det) %>%   # simplify
  
  # remove unnecessary column
  select(-row_num) %>% 
  
  # clean existing columns
  mutate(
    
    # clean weight
    wt_kg = ifelse(
      test = wt_kg < 0,    # if weight is negative
      yes = NA,            # convert to missing
      no = wt_kg),         # else keep original value
    
    # clean date of onset
    date_onset = mdy(date_onset),        # convert to date
    
    # clean date of report
    date_report = mdy(date_report)) %>%  # convert to date
  
  # de-duplicate, remove rows 100% similar
  distinct() %>% 
  
  # further recoding and cleaning of columns
  mutate(
    # prioritize detetion location over residence
    district = coalesce(district_det, district_res),
    
    # convert to NA
    gender = na_if(gender, "Unknown"), 
    
    # clean hospital spellings
    hospital_clean = recode(hospital,
      "Mitilary Hospital"  = "Military Hospital",
      "Port"               = "Port Hospital",
      "Port Hopital"       = "Port Hospital",
      "St. Mark's Maternity Hospital (SMMH)" = "SMMH"), 
    
    # create case definition
    case_def = case_when(
      
      # if lab confirmed
      lab_confirmed == TRUE             ~ "Confirmed case",
      
      # else if epilink and fever
      epilink == "yes" & fever == "yes" ~ "Suspect case",
      
      # all others
      TRUE                              ~ "To investigate"),
    
    # create age in years
    age_years = case_when(
      age_unit == "years"  ~ age,    # leave as years
      age_unit == "months" ~ age/12, # convert months to years
      is.na(age_unit)      ~ age),   # if age unit missing, assume years
    
    # fix temperatures recorded in Farinheit
    temp = case_when(
      temp > 90 & temp < 120 ~ (temp - 32) * 5 / 9,
      TRUE                   ~ temp),
    
    # make age categories
    age_cat = age_categories(age_years,
      lower = 0,
      upper = 70,
      by = 5))
```

This is long, but it a reproducible and well-documented record of all your cleaning steps. You could send this to a colleague and they could repeat and critique all of your steps. In the end, that makes for better science and more efficient insights!  


```{r, echo=FALSE, eval=TRUE}
# save current state of demo
demo <- linelist_raw %>% 
  clean_names() %>% 
  rename(
    date_onset = onset_date,            # list date first
    date_report = date_of_report,       # standardize
    district_res = adm3_name_res,       # simplify
    district_det = adm3_name_det) %>%   # simplify
  select(-row_num) %>% 
  mutate(
    wt_kg = ifelse(
      test = wt_kg < 0,    # if weight is negative
      yes = NA,            # convert to missing
      no = wt_kg),         # else keep original value
    date_onset = mdy(date_onset),        # convert to date
    date_report = mdy(date_report)) %>%  # convert to date
  distinct() %>% 
  mutate(
    district = coalesce(district_det, district_res),
    gender = na_if(gender, "Unknown"), 
    hospital_clean = recode(hospital,
      "Mitilary Hospital"  = "Military Hospital",
      "Port"               = "Port Hospital",
      "Port Hopital"       = "Port Hospital",
      "St. Mark's Maternity Hospital (SMMH)" = "SMMH"), 
    case_def = case_when(
      lab_confirmed == TRUE             ~ "Confirmed case",
      epilink == "yes" & fever == "yes" ~ "Suspect case",
      TRUE                              ~ "To investigate"),
    age_years = case_when(
      age_unit == "years"  ~ age,
      age_unit == "months" ~ age/12,
      is.na(age_unit)      ~ age),
    temp = case_when(
      temp > 90 & temp < 120 ~ (temp - 32) * 5 / 9,
      TRUE                   ~ temp),
    age_cat = age_categories(age_years,
      lower = 0,
      upper = 70,
      by = 5))
```



## Filtering

Sub-setting rows is done with the function `filter()`. Inside the parentheses you write logical criteria (using "==", "!=", ">", "<", etc) that are applied to each row. Rows that meet the criteria are kept. 

See the previous tutorial, or the [Basics chapter of the Epi R Handbook](https://epirhandbook.com/en/r-basics.html#relational-and-logical-operators) to review the logical operators.  

Here are some examples:  

A simple filter is applied that keeps only rows in which `age_years` is greater than 10.  

```{r eval=FALSE, echo=TRUE}
linelist %>% 
  filter(age_years > 10)
```

Additional required ("AND") criteria can be added with a comma, or with &.  

```{r eval=FALSE, echo=TRUE}
linelist %>% 
  filter(age_years > 10, gender == "m")
```

Logic can get quite complex using `&` (AND), `|` (OR), and parentheses:  

```{r eval=FALSE, echo=TRUE}
linelist %>% 
  filter(age_years > 10 & (gender == "m" | case_def == "To investigate"))
```

The above command keeps rows that have age above 10 and EITHER male gender OR are still under investigation.  


## End  

Congratulation on finishing this tutorial!  If you have extra time, consider completing the extra exercises below. Otherwise, we welcome you to advance to the next tutorial in the series.  

Please consider making a donation to us. We are a nonprofit organization and rely on your contributions to continue supporting frontline epidemiologists around the world.


<form target="_blank" action="https://www.paypal.com/donate" method="post" target="_top">
<input type="hidden" name="hosted_button_id" value="YTEZELC8VBXV6" />
<input type="image" src="https://github.com/appliedepi/epiRhandbook_eng/raw/master/images/donate_button_long.png" border="0" name="submit" title="PayPal - The safer, easier way to pay online!" alt="Donate with PayPal button" />
<img alt="" border="0" src="https://www.paypal.com/en_US/i/scr/pixel.gif" />
</form>





## Extra exercises  


### GIS dataset  


Your GIS team needs a data frame to put into their routine maps for this outbreak. They use R, so they expect a .rds file (exported R data frame) containing the `case_id`, the columns `district`, `district_res`, `district_det`, `lat`, and `lon`).  

**Can you make this file for them?**  

```{r gis, exercise=TRUE}
gis_data <- linelist %>% 
```

```{r gis-hint}
Use a select() command
```

```{r gis-hint-2}
# create data frame with only gis information
gis_data <- linelist %>% 
  select(case_id, district, district_res, district_det, lat, lon)
```

```{r gis-solution, eval=FALSE}
# create data frame with only gis information
gis_data <- linelist %>% 
  select(case_id, district, district_res, district_det, lat, lon)
```

```{r gis-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal(message =  "Excellent, you have cleaned the dataset as expected!")
    # Default to failing grade with feedback
    fail()
  })
```


### Spotlight on children  

**Create a separate data frame for analysis of children.**  

* Start from the clean data frame `linelist` and assign this new data frame with the name `children`  
* Reduce the data frame to only contain cases with `age_years` less than 18 years  
* Create a new column `infant` that says "Infant" if the case is less than 1 year old, and says "Non-infant" otherwise  
* Reduce the data frame to only show the columns `case_id`, `age_years`, `infant`, `gender`, `district`, and `date_report`  

```{r children, exercise=TRUE}
children <- linelist %>% 
```

```{r children-hint}
Use a filter(), then a mutate() with ifelse(), then select()
```

```{r children-hint-2}
# create data frame with only child cases
children <- linelist %>% 
  filter(age_years < 18) %>% 
  mutate(infant = ifelse(age_years < 1, "Infant", "Non-infant")) %>% 
  select(case_id, age_years, infant, gender, district, date_report)
```

```{r children-solution, eval=FALSE}
# create data frame with only child cases
children <- linelist %>% 
  filter(age_years < 18) %>% 
  mutate(infant = ifelse(age_years < 1, "Infant", "Non-infant")) %>% 
  select(case_id, age_years, infant, gender, district, date_report)
```

```{r children-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal(message =  "Excellent, you have cleaned the dataset as expected!")
    # Default to failing grade with feedback
    fail()
  })
```





### String detection  

The R package {stringr} is part of the {tidyverse} and contains many different functions to handle words and character "strings". If you ever want to split, unite, or search within a character value, you should look in the [Characters and strings chapter of the Epi R Handbook](https://epirhandbook.com/en/characters-and-strings.html).  

For example the function `str_detect()` returns `TRUE` or `FALSE` depending on whether particular characters are found within a specified value. The true arguments are:  

1) `string = ` this is the column or text to search in  
2) `pattern = ` this the character pattern to search for  

For example:  

* `str_detect(string = name, pattern = "Isha")` will return `TRUE` if the characters "Isha" are found in a particular row of the colunm `name`  
* `str_detect(string = occupation, pattern = "nurse")` will return `TRUE` if the characters "nurse" are found in a particular row of the colunm `occupation`  

Be aware that this function is *case sensitive* by default. You can adjust this using the tip found [here](https://epirhandbook.com/en/characters-and-strings.html#detect-a-pattern) in the Epi R Handbook.

**Now, starting with the clean data frame `linelist`, create a new data frame that contains only the cases reported from district whose names contains "West".**  

```{r west, exercise=TRUE}
western_cases <- linelist %>% 
```

```{r west-hint}
Use a select() command
```

```{r west-hint-2}
# create data frame with only cases from the "West" districts
western_cases <- linelist %>% 
  filter(str_detect(string = district, pattern = "West"))
```

```{r west-solution, eval=FALSE}
# create data frame with only cases from the "West" districts
western_cases <- linelist %>% 
  filter(str_detect(string = district, pattern = "West"))
```

```{r west-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal(message =  "Excellent, you have cleaned the dataset as expected!")
    # Default to failing grade with feedback
    fail()
  })
```

```{r, eval=TRUE, echo=FALSE}
western_cases_n <- linelist %>% 
  filter(str_detect(string = district, pattern = "West")) %>% 
  nrow()
```

```{r quiz-western, echo = FALSE}
quiz(caption = "Quiz - Western districts",
  question("How many cases were there in western districts?",
    allow_retry = TRUE,
    answer("170"),
    answer("258", correct = TRUE),
    answer("418")
  )
)
```
